# DNASPEC 真实场景使用指南 - 通过 iflow 调用

## 🎯 真实使用场景

### 场景说明

在真实的项目开发中，开发者使用 iflow（或其他 AI CLI 工具）时，会通过**自然语言**与 AI 对话，AI 大模型会理解用户需求并调用相应的 DNASPEC 技能。

**关键点**：
- ✅ 用户使用自然语言描述需求
- ✅ 大模型理解需求并决定使用哪个技能
- ✅ 大模型调用技能获得结果
- ✅ 大模型智能分析和总结结果
- ✅ 返回给用户可操作的答案

---

## 📝 真实使用示例

### 示例 1: 任务分解场景

**用户操作**：
```bash
# 打开 iflow
cd /path/to/project
iflow

# 在 iflow 交互界面输入：
我正在开发一个电商平台，技术栈是 React + Node.js，团队10人，开发周期3个月。请帮我将这个项目分解为具体的开发任务。
```

**大模型的智能处理流程**：
1. 理解需求：这是一个项目任务分解需求
2. 决定使用技能：应该调用 task-decomposer 技能
3. 调用技能：执行 DNASPEC 的 task-decomposer
4. 理解技能结果：分析返回的任务结构
5. 智能总结：将技术结果转化为可读的项目计划
6. 返回给用户：清晰的开发任务列表

**AI 返回示例**：
```
好的，我来帮您将电商平台项目分解为具体的开发任务。

基于您的项目信息（10人团队、3个月、React + Node.js），我为您制定以下开发计划：

## 第一阶段：基础架构搭建（第1-2周）

### 任务组1：开发环境配置
- [ ] 搭建 CI/CD 流水线（Jenkins/GitLab CI）
  - 负责人：DevOps工程师
  - 工时：3天
  - 依赖：无

- [ ] 配置开发环境 Docker 镜像
  - 负责人：DevOps工程师
  - 工时：2天
  - 依赖：CI/CD 搭建完成

### 任务组2：代码规范制定
- [ ] 配置 ESLint + Prettier
  - 负责人：前端 + 后端负责人
  - 工时：1天

- [ ] 编写代码规范文档
  - 负责人：技术负责人
  - 工时：1天

## 第二阶段：核心功能开发（第3-8周）

### Epic 1: 用户认证系统（第3-4周）
- [ ] 用户注册/登录 API
- [ ] JWT 权限验证
- [ ] 密码加密存储
- [ ] 单元测试编写

### Epic 2: 商品管理（第4-6周）
- [ ] 商品 CRUD API
- [ ] 图片上传功能
- [ ] 商品分类管理
- [ ] 库存管理接口

### Epic 3: 购物车（第6-7周）
- [ ] 购物车 API
- [ ] 购物车缓存（Redis）
- [ ] 库存预占机制

### Epic 4: 订单系统（第7-8周）
- [ ] 订单创建流程
- [ ] 订单状态机
- [ ] 订单支付对接

## 第三阶段：扩展功能（第9-11周）

### Epic 5: 商家后台（第9-10周）
- [ ] 商品管理界面
- [ ] 订单处理界面
- [ ] 数据统计仪表板

### Epic 6: 搜索推荐（第10-11周）
- [ ] Elasticsearch 集成
- [ ] 商品搜索 API
- [ ] 推荐算法实现

## 第四阶段：测试上线（第12周）

- [ ] 全链路测试
- [ ] 性能优化
- [ ] 安全扫描
- [ ] 灰度发布

---

**关键要点**：
✅ 总任务数：约 60+ 个具体任务
✅ 团队分配：前端 2人、后端 3人并行开发
✅ 里程碑明确：每 2 周一个里程碑
✅ 依赖关系清晰：核心功能优先开发

需要我详细展开某个具体的任务吗？或者您想调整某个阶段的安排？
```

---

### 示例 2: 架构设计场景

**用户操作**：
```bash
# 在 iflow 中输入：
我需要为电商平台设计微服务架构，要求支持10万并发，99.99%可用性。技术栈是 Node.js + PostgreSQL + Redis。请帮我设计一个高可用的微服务架构方案。
```

**AI 返回示例**：
```
好的，我来帮您设计一个高可用的微服务架构方案。

## 架构设计方案

### 整体架构

```
                        ┌─────────────────┐
                        │   Load Balancer │
                        │    (Nginx/ALB)   │
                        └────────┬─────────┘
                                 │
                    ┌────────────┴────────────┐
                    │                          │
             ┌──────┴──────┐          ┌───────┴───────┐
             │  Web App 1  │          │  Web App 2   │
             │   (React)   │          │   (React)    │
             └─────────────┘          └──────────────┘
                    │                          │
                    └────────────┬─────────────┘
                                 │
                        ┌────────┴─────────┐
                        │  API Gateway     │
                        │  (Kong/Nginx)    │
                        └────────┬─────────┘
                                 │
        ┌────────────────────────┼────────────────────────┐
        │                        │                        │
 ┌──────┴──────┐      ┌─────────┴────────┐    ┌─────────┴────────┐
 │User Service │      │Product Service  │    │Order Service     │
│(Node.js)    │      │(Node.js)        │    │(Node.js)         │
│Port: 3001   │      │Port: 3002       │    │Port: 3003        │
└──────┬──────┘      └─────────┬────────┘    └─────────┬────────┘
       │                       │                       │
       └───────────────────────┴───────────────────────┘
                                       │
                            ┌──────────┴──────────┐
                            │                    │
                     ┌──────┴──────┐      ┌──────┴───────┐
                     │ PostgreSQL  │      │    Redis     │
                     │  (1主2从)   │      │   Cluster    │
                     └─────────────┘      └──────────────┘
```

### 服务拆分方案

#### 1. 用户服务 (User Service)
**职责**：
- 用户注册/登录
- JWT Token 签发
- 用户信息管理

**技术选型**：
- 框架：Express + TypeScript
- 数据库：PostgreSQL (user表)
- 缓存：Redis (session存储)
- 部署：2个实例（支持滚动升级）

**接口设计**：
```
POST /api/users/register
POST /api/users/login
GET  /api/users/:id
PUT  /api/users/:id
```

#### 2. 商品服务 (Product Service)
**职责**：
- 商品 CRUD
- 商品分类管理
- 库存管理

**技术选型**：
- 框架：Express + TypeScript
- 数据库：PostgreSQL (product表)
- 缓存：Redis (商品详情缓存)
- 搜索：Elasticsearch

**接口设计**：
```
GET    /api/products
GET    /api/products/:id
POST   /api/products
PUT    /api/products/:id
DELETE /api/products/:id
GET    /api/products/:id/stock
```

#### 3. 订单服务 (Order Service)
**职责**：
- 订单创建
- 订单状态流转
- 订单支付对接

**技术选型**：
- 框架：Express + TypeScript
- 数据库：PostgreSQL (order表)
- 消息队列：RabbitMQ (订单事件)
- 缓存：Redis (订单状态缓存)

**接口设计**：
```
POST /api/orders
GET  /api/orders/:id
GET  /api/orders
PUT  /api/orders/:id/status
```

### 高可用设计

#### 1. 负载均衡
- **入口层**：阿里云 SLB / AWS ALB
- **应用层**：Nginx 反向代理
- **服务层**：每个服务部署 2-3 个实例

#### 2. 数据库高可用
- **主从复制**：1主2从，自动故障转移
- **读写分离**：写操作主库，读操作从库
- **连接池**：使用 PgBouncer 管理

#### 3. 缓存高可用
- **Redis Cluster**：3主3从
- **缓存预热**：系统启动时加载热数据
- **缓存降级**：缓存故障时直接查数据库

#### 4. 容错机制
- **熔断器**：使用 Hystrix.js 防止雪崩
- **超时控制**：每个请求设置超时（3秒）
- **限流**：使用 Redis + Lua 实现限流
- **降级**：核心服务优先，非核心服务降级

### 扩展性方案

#### 应对大促流量

**水平扩展**：
- 通过 Kubernetes 自动扩容
- 根据 CPU/内存使用率自动增加实例
- 支持从 5 个实例扩展到 50 个实例

**弹性伸缩策略**：
- 日常：每个服务 2 个实例
- 大促前：提前扩容到 5 个实例
- 大促期间：自动扩容到 20+ 个实例
- 大促后：自动缩容回 2 个实例

### 数据一致性

#### 分布式事务方案

**方案选择**：最终一致性 + Saga 模式

**订单创建流程**：
```
1. 订单服务创建订单（PENDING状态）
2. 通过消息队列通知：
   - 库存服务：预占库存
   - 支付服务：创建支付单
   - 通知服务：发送订单确认邮件
3. 支付成功后：
   - 订单服务更新订单状态（PAID）
   - 通知库存服务：扣减库存
   - 通知通知服务：发送支付成功通知
4. 任何步骤失败：
   - 执行补偿操作
   - 订单标记为失败
   - 发送失败通知
```

### 性能优化

#### 1. 缓存策略
- 商品详情：Redis 缓存，TTL 1小时
- 用户信息：Redis 缓存，TTL 30分钟
- 热门商品：前置 CDN 缓存

#### 2. 数据库优化
- 索引优化：为常用查询字段建立索引
- 分表策略：订单表按月分表
- 读写分离：80% 读操作走从库

#### 3. API 优化
- 响应压缩：启用 gzip
- 批量查询：支持批量获取商品信息
- 分页查询：所有列表接口支持分页

### 部署架构

#### Kubernetes 部署
```
Namespace: production

Pods:
- user-service-0 (2 replicas)
- product-service-0 (3 replicas)
- order-service-0 (3 replicas)
- payment-service-0 (2 replicas)

Services:
- ClusterIP for inter-service communication
- LoadBalancer for external access

Ingress:
- Nginx Ingress Controller
- TLS termination
```

---

**架构评估**：
✅ 可用性：99.99% (年停机 < 52分钟)
✅ 并发能力：支持 10万 QPS
✅ 响应时间：P95 < 200ms
✅ 扩展性：支持水平扩展到 100+ 实例

**下一步建议**：
1. 先实现 MVP（最小可行产品）
2. 进行性能压测验证架构
3. 根据压测结果优化瓶颈
4. 制定详细的容量规划

需要我详细说明某个具体部分吗？或者您有其他的约束条件需要考虑？
```

---

## 🔑 关键差异对比

### ❌ 错误方式（脚本调用）
```python
# 直接调用 Python API
result = executor.execute('architect', '设计架构')
print(result)
```
- 没有大模型理解
- 没有智能分析
- 技能结果难以直接使用

### ✅ 正确方式（通过 iflow）
```bash
# 在 iflow 中用自然语言描述
iflow "我需要设计一个高可用的电商架构，要求支持10万并发..."
```
- ✅ 大模型理解需求
- ✅ 大模型选择合适的技能
- ✅ 大模型分析并总结结果
- ✅ 返回可操作的方案

---

## 💡 总结

真实场景中：
1. 用户用**自然语言**描述需求
2. AI 大模型**理解并决定**使用哪个技能
3. 技能执行后，大模型**智能总结**结果
4. 用户获得**可操作的答案**

**关键**：DNASPEC 技能是"幕后英雄"，大模型是"智能中台"！
