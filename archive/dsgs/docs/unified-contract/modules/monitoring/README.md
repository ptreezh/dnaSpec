# æœåŠ¡ç›‘æ§æ¨¡å—

## ğŸ“‹ æ¨¡å—æ¦‚è§ˆ

æœåŠ¡ç›‘æ§æ¨¡å—è´Ÿè´£DSGSç³»ç»Ÿçš„å¥åº·æ£€æŸ¥ã€æ€§èƒ½æŒ‡æ ‡æ”¶é›†ã€è‡ªåŠ¨æ¢å¤å’Œå‘Šè­¦é€šçŸ¥ã€‚ç¡®ä¿ç³»ç»Ÿçš„é«˜å¯ç”¨æ€§å’Œå¯è§‚æµ‹æ€§ã€‚

### ğŸ¯ æ ¸å¿ƒåŠŸèƒ½
- **å®æ—¶å¥åº·æ£€æŸ¥**ï¼šç›‘æ§æ‰€æœ‰æ ¸å¿ƒç»„ä»¶çš„å¥åº·çŠ¶æ€
- **æ€§èƒ½æŒ‡æ ‡æ”¶é›†**ï¼šæ”¶é›†ç³»ç»Ÿæ€§èƒ½å’Œä¸šåŠ¡æŒ‡æ ‡
- **è‡ªåŠ¨æ¢å¤æœºåˆ¶**ï¼šæ•…éšœæ—¶è‡ªåŠ¨æ¢å¤æœåŠ¡
- **æ™ºèƒ½å‘Šè­¦**ï¼šåŸºäºè§„åˆ™çš„å‘Šè­¦å’Œé€šçŸ¥

### ğŸ“Š ç›‘æ§èŒƒå›´
| ç»„ä»¶ | ç›‘æ§å†…å®¹ | å‘Šè­¦é˜ˆå€¼ |
|------|----------|----------|
| **MCPæœåŠ¡å™¨** | è¿æ¥çŠ¶æ€ã€æ¶ˆæ¯å¤„ç†å»¶è¿Ÿã€é”™è¯¯ç‡ | å»¶è¿Ÿ>1sï¼Œé”™è¯¯ç‡>5% |
| **çº¦æŸç”Ÿæˆå™¨** | ç”Ÿæˆæ—¶é—´ã€æˆåŠŸç‡ã€æ¨¡æ¿åŒ¹é… | ç”Ÿæˆæ—¶é—´>100msï¼ŒæˆåŠŸç‡<95% |
| **ç¥ç»åœºå¤„ç†** | å†²çªæ£€æµ‹æ—¶é—´ã€æ”¶æ•›é€Ÿåº¦ | æ£€æµ‹æ—¶é—´>500msï¼Œæ”¶æ•›æ—¶é—´>1s |
| **æ•°æ®åº“** | è¿æ¥æ± çŠ¶æ€ã€æŸ¥è¯¢æ€§èƒ½ | è¿æ¥å¤±è´¥ç‡>1%ï¼ŒæŸ¥è¯¢æ—¶é—´>100ms |
| **ç³»ç»Ÿèµ„æº** | CPUã€å†…å­˜ã€ç£ç›˜ã€ç½‘ç»œ | CPU>80%ï¼Œå†…å­˜>85% |

## ğŸ”— å¿«é€Ÿå¯¼èˆª

### ğŸ“– æ ¸å¿ƒæ–‡æ¡£
- [å¥åº·æ£€æŸ¥API](#å¥åº·æ£€æŸ¥-api) - å¥åº·æ£€æŸ¥æ¥å£å®šä¹‰
- [æŒ‡æ ‡æ”¶é›†API](#æŒ‡æ ‡æ”¶é›†-api) - æ€§èƒ½æŒ‡æ ‡æ¥å£
- [å‘Šè­¦ç®¡ç†API](#å‘Šè­¦ç®¡ç†-api) - å‘Šè­¦ç®¡ç†æ¥å£
- [æ•°æ®æ¨¡å‹](#æ•°æ®æ¨¡å‹) - ç›‘æ§ç›¸å…³æ•°æ®ç»“æ„

### ğŸ”§ å®ç°æŒ‡å—
- [å¥åº·æ£€æŸ¥å®ç°](#å¥åº·æ£€æŸ¥å®ç°) - å¥åº·æ£€æŸ¥æœåŠ¡å®ç°
- [æŒ‡æ ‡æ”¶é›†å®ç°](#æŒ‡æ ‡æ”¶é›†å®ç°) - æŒ‡æ ‡æ”¶é›†å™¨å®ç°
- [è‡ªåŠ¨æ¢å¤å®ç°](#è‡ªåŠ¨æ¢å¤å®ç°) - è‡ªåŠ¨æ¢å¤æœºåˆ¶å®ç°
- [å‘Šè­¦ç³»ç»Ÿå®ç°](#å‘Šè­¦ç³»ç»Ÿå®ç°) - å‘Šè­¦ç³»ç»Ÿå®ç°

### ğŸ“Š é…ç½®æŒ‡å—
- [ç›‘æ§é…ç½®](#ç›‘æ§é…ç½®) - ç›‘æ§ç»„ä»¶é…ç½®
- [å‘Šè­¦é…ç½®](#å‘Šè­¦é…ç½®) - å‘Šè­¦è§„åˆ™é…ç½®
- [å­˜å‚¨é…ç½®](#å­˜å‚¨é…ç½®) - æ•°æ®å­˜å‚¨é…ç½®

## ğŸš€ APIæ¥å£

### å¥åº·æ£€æŸ¥ API

#### è·å–ç³»ç»Ÿå¥åº·çŠ¶æ€
```typescript
// GET /api/monitoring/health
interface HealthResponse {
  status: 'healthy' | 'degraded' | 'unhealthy';
  timestamp: string;
  version: string;
  uptime: number;
  components: ComponentHealth[];
  metrics: SystemMetrics;
  issues: HealthIssue[];
  recommendations: string[];
}
```

**ç¤ºä¾‹è¯·æ±‚**ï¼š
```bash
curl -X GET "http://localhost:3000/api/monitoring/health" \
  -H "Authorization: Bearer ${TOKEN}"
```

**ç¤ºä¾‹å“åº”**ï¼š
```json
{
  "status": "healthy",
  "timestamp": "2025-08-06T10:00:00Z",
  "version": "2.0.0",
  "uptime": 86400,
  "components": [
    {
      "name": "mcpServer",
      "status": "healthy",
      "details": "Running normally",
      "lastCheck": "2025-08-06T10:00:00Z",
      "metrics": {
        "activeConnections": 15,
        "messageProcessingTime": 45
      }
    }
  ],
  "metrics": {
    "cpu": 25.5,
    "memory": 67.2,
    "disk": 45.8
  },
  "issues": [],
  "recommendations": []
}
```

#### è·å–ç»„ä»¶å¥åº·çŠ¶æ€
```typescript
// GET /api/monitoring/health/components/{componentName}
interface ComponentHealthResponse {
  name: string;
  status: 'healthy' | 'degraded' | 'unhealthy';
  details: string;
  lastCheck: string;
  metrics: ComponentMetrics;
  dependencies: string[];
  history: HealthHistory[];
}
```

### æŒ‡æ ‡æ”¶é›† API

#### è·å–ç³»ç»ŸæŒ‡æ ‡
```typescript
// GET /api/monitoring/metrics
interface MetricsResponse {
  system: SystemMetrics;
  components: ComponentMetrics[];
  business: BusinessMetrics[];
  custom: CustomMetric[];
  timestamp: string;
}
```

#### è·å–ç‰¹å®šæŒ‡æ ‡
```typescript
// GET /api/monitoring/metrics/{metricName}
interface MetricResponse {
  name: string;
  value: number;
  labels: Record<string, string>;
  timestamp: string;
  history: MetricHistory[];
}
```

### å‘Šè­¦ç®¡ç† API

#### è·å–æ´»è·ƒå‘Šè­¦
```typescript
// GET /api/monitoring/alerts
interface AlertsResponse {
  alerts: Alert[];
  totalCount: number;
  filteredCount: number;
  page: number;
  limit: number;
}
```

#### è§£å†³å‘Šè­¦
```typescript
// POST /api/monitoring/alerts/{alertId}/resolve
interface ResolveAlertResponse {
  success: boolean;
  message: string;
  resolvedAt: string;
  resolvedBy: string;
}
```

## ğŸ“Š æ•°æ®æ¨¡å‹

### æ ¸å¿ƒæ•°æ®æ¨¡å‹

#### å¥åº·çŠ¶æ€ (HealthStatus)
```typescript
interface HealthStatus {
  status: 'healthy' | 'degraded' | 'unhealthy';
  timestamp: string;
  version: string;
  uptime: number;
  components: ComponentHealth[];
  metrics: SystemMetrics;
  issues: HealthIssue[];
  recommendations: string[];
}

interface ComponentHealth {
  name: string;
  status: 'healthy' | 'degraded' | 'unhealthy';
  details: string;
  lastCheck: string;
  metrics?: ComponentMetrics;
  dependencies?: string[];
}

interface HealthIssue {
  id: string;
  type: 'performance' | 'connection' | 'resource' | 'business';
  severity: 'low' | 'medium' | 'high' | 'critical';
  message: string;
  component?: string;
  timestamp: string;
  resolved: boolean;
  resolvedAt?: string;
  resolvedBy?: string;
}
```

#### ç³»ç»ŸæŒ‡æ ‡ (SystemMetrics)
```typescript
interface SystemMetrics {
  cpu: {
    usage: number;
    cores: number;
    loadAverage: number[];
  };
  memory: {
    total: number;
    used: number;
    free: number;
    usage: number;
  };
  disk: {
    total: number;
    used: number;
    free: number;
    usage: number;
  };
  network: {
    bytesIn: number;
    bytesOut: number;
    packetsIn: number;
    packetsOut: number;
  };
}

interface ComponentMetrics {
  requestCount: number;
  errorCount: number;
  averageResponseTime: number;
  lastRequestTime: string;
  customMetrics: Record<string, number>;
}
```

#### å‘Šè­¦ (Alert)
```typescript
interface Alert {
  id: string;
  name: string;
  description: string;
  type: 'performance' | 'connection' | 'resource' | 'business';
  severity: 'low' | 'medium' | 'high' | 'critical';
  status: 'active' | 'resolved' | 'suppressed';
  component?: string;
  metric?: string;
  threshold: number;
  currentValue: number;
  triggeredAt: string;
  resolvedAt?: string;
  resolvedBy?: string;
  notifications: Notification[];
}

interface Notification {
  id: string;
  channel: 'email' | 'slack' | 'webhook';
  recipient: string;
  sentAt: string;
  status: 'sent' | 'failed' | 'delivered';
}
```

## ğŸ”§ å®ç°ç»†èŠ‚

### å¥åº·æ£€æŸ¥å®ç°

#### å¥åº·æ£€æŸ¥æœåŠ¡
```typescript
// src/core/monitoring/HealthCheckService.ts
export class HealthCheckService {
  private components: Map<string, HealthChecker> = new Map();
  private metrics: MetricsCollector;
  private recoveryManager: RecoveryManager;
  
  constructor() {
    this.initializeComponents();
    this.startHealthChecks();
  }
  
  private initializeComponents() {
    // æ³¨å†Œæ‰€æœ‰éœ€è¦ç›‘æ§çš„ç»„ä»¶
    this.components.set('mcpServer', new McpServerHealthChecker());
    this.components.set('constraintGenerator', new ConstraintGeneratorHealthChecker());
    this.components.set('neuralField', new NeuralFieldHealthChecker());
    this.components.set('database', new DatabaseHealthChecker());
  }
  
  async getSystemHealth(): Promise<HealthStatus> {
    const componentHealths = await Promise.all(
      Array.from(this.components.values()).map(checker => checker.check())
    );
    
    const overallStatus = this.calculateOverallStatus(componentHealths);
    const metrics = await this.metrics.collectSystemMetrics();
    const issues = this.identifyIssues(componentHealths);
    const recommendations = this.generateRecommendations(issues);
    
    return {
      status: overallStatus,
      timestamp: new Date().toISOString(),
      version: process.env.VERSION || '2.0.0',
      uptime: process.uptime(),
      components: componentHealths,
      metrics,
      issues,
      recommendations
    };
  }
  
  private calculateOverallStatus(components: ComponentHealth[]): HealthStatus['status'] {
    const hasUnhealthy = components.some(c => c.status === 'unhealthy');
    const hasDegraded = components.some(c => c.status === 'degraded');
    
    if (hasUnhealthy) return 'unhealthy';
    if (hasDegraded) return 'degraded';
    return 'healthy';
  }
}
```

#### ç»„ä»¶å¥åº·æ£€æŸ¥å™¨
```typescript
// src/core/monitoring/checkers/McpServerHealthChecker.ts
export class McpServerHealthChecker implements HealthChecker {
  private mcpServer: McpServer;
  
  constructor(mcpServer: McpServer) {
    this.mcpServer = mcpServer;
  }
  
  async check(): Promise<ComponentHealth> {
    try {
      const startTime = Date.now();
      
      // æ£€æŸ¥è¿æ¥çŠ¶æ€
      const isConnected = await this.mcpServer.isConnected();
      if (!isConnected) {
        return {
          name: 'mcpServer',
          status: 'unhealthy',
          details: 'MCP server is not connected',
          lastCheck: new Date().toISOString()
        };
      }
      
      // æ£€æŸ¥æ¶ˆæ¯å¤„ç†å»¶è¿Ÿ
      const processingTime = await this.mcpServer.getProcessingTime();
      const activeConnections = await this.mcpServer.getActiveConnections();
      
      // ç¡®å®šå¥åº·çŠ¶æ€
      let status: ComponentHealth['status'] = 'healthy';
      let details = 'Running normally';
      
      if (processingTime > 1000) {
        status = 'degraded';
        details = `High processing time: ${processingTime}ms`;
      }
      
      if (processingTime > 5000) {
        status = 'unhealthy';
        details = `Critical processing time: ${processingTime}ms`;
      }
      
      return {
        name: 'mcpServer',
        status,
        details,
        lastCheck: new Date().toISOString(),
        metrics: {
          activeConnections,
          messageProcessingTime: processingTime,
          checkDuration: Date.now() - startTime
        }
      };
      
    } catch (error) {
      return {
        name: 'mcpServer',
        status: 'unhealthy',
        details: `Health check failed: ${error.message}`,
        lastCheck: new Date().toISOString()
      };
    }
  }
}
```

### æŒ‡æ ‡æ”¶é›†å®ç°

#### æŒ‡æ ‡æ”¶é›†å™¨
```typescript
// src/core/monitoring/MetricsCollector.ts
export class MetricsCollector {
  private prometheusClient: PrometheusClient;
  private metrics: Map<string, Metric> = new Map();
  
  constructor() {
    this.prometheusClient = new PrometheusClient();
    this.initializeMetrics();
  }
  
  private initializeMetrics() {
    // ç³»ç»ŸæŒ‡æ ‡
    this.createGauge('system_cpu_usage_percent', 'System CPU usage percentage');
    this.createGauge('system_memory_usage_bytes', 'System memory usage in bytes');
    this.createGauge('system_disk_usage_bytes', 'System disk usage in bytes');
    
    // MCPæœåŠ¡å™¨æŒ‡æ ‡
    this.createCounter('mcp_requests_total', 'Total MCP requests', ['method', 'status']);
    this.createHistogram('mcp_request_duration_seconds', 'MCP request duration', ['method']);
    this.createGauge('mcp_active_connections', 'Active MCP connections');
    
    // çº¦æŸç”Ÿæˆå™¨æŒ‡æ ‡
    this.createHistogram('constraint_generation_duration', 'Constraint generation duration');
    this.createCounter('constraint_template_matches_total', 'Total template matches', ['template_id']);
    this.createCounter('constraint_validation_errors_total', 'Total validation errors', ['error_type']);
    
    // ç¥ç»åœºæŒ‡æ ‡
    this.createHistogram('neural_field_processing_time', 'Neural field processing time');
    this.createCounter('constraint_conflicts_detected_total', 'Total constraint conflicts detected');
    this.createHistogram('attractor_convergence_time', 'Attractor convergence time');
  }
  
  recordMcpRequest(method: string, duration: number, status: string) {
    this.metrics.get('mcp_requests_total')?.inc({ method, status });
    this.metrics.get('mcp_request_duration_seconds')?.observe({ method }, duration);
  }
  
  recordConstraintGeneration(duration: number, templateId?: string) {
    this.metrics.get('constraint_generation_duration')?.observe(duration);
    if (templateId) {
      this.metrics.get('constraint_template_matches_total')?.inc({ template_id: templateId });
    }
  }
  
  async collectSystemMetrics(): Promise<SystemMetrics> {
    const cpuUsage = await this.getCpuUsage();
    const memoryUsage = await this.getMemoryUsage();
    const diskUsage = await this.getDiskUsage();
    const networkUsage = await this.getNetworkUsage();
    
    return {
      cpu: cpuUsage,
      memory: memoryUsage,
      disk: diskUsage,
      network: networkUsage
    };
  }
}
```

### è‡ªåŠ¨æ¢å¤å®ç°

#### æ¢å¤ç®¡ç†å™¨
```typescript
// src/core/monitoring/RecoveryManager.ts
export class RecoveryManager {
  private recoveryStrategies: Map<string, RecoveryStrategy> = new Map();
  private healthCheckService: HealthCheckService;
  private alertManager: AlertManager;
  
  constructor() {
    this.initializeRecoveryStrategies();
    this.startMonitoring();
  }
  
  private initializeRecoveryStrategies() {
    this.recoveryStrategies.set('mcpServer', new McpServerRecoveryStrategy());
    this.recoveryStrategies.set('constraintGenerator', new ConstraintGeneratorRecoveryStrategy());
    this.recoveryStrategies.set('neuralField', new NeuralFieldRecoveryStrategy());
  }
  
  private startMonitoring() {
    setInterval(async () => {
      const health = await this.healthCheckService.getSystemHealth();
      
      for (const component of health.components) {
        if (component.status !== 'healthy') {
          await this.attemptRecovery(component.name, component.status);
        }
      }
    }, 30000); // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡
  }
  
  private async attemptRecovery(componentName: string, status: ComponentHealth['status']) {
    const strategy = this.recoveryStrategies.get(componentName);
    if (!strategy) return;
    
    try {
      console.log(`Attempting recovery for ${componentName} (${status})`);
      await strategy.recover(status);
      
      // éªŒè¯æ¢å¤æ˜¯å¦æˆåŠŸ
      await this.verifyRecovery(componentName);
      
    } catch (error) {
      console.error(`Recovery failed for ${componentName}:`, error);
      // è§¦å‘å‘Šè­¦
      await this.alertManager.createAlert({
        name: `Recovery Failed: ${componentName}`,
        description: `Automatic recovery failed for ${componentName}: ${error.message}`,
        type: 'system',
        severity: 'high',
        component: componentName
      });
    }
  }
  
  private async verifyRecovery(componentName: string) {
    const health = await this.healthCheckService.getComponentHealth(componentName);
    
    if (health.status === 'healthy') {
      console.log(`Recovery successful for ${componentName}`);
    } else {
      throw new Error(`Recovery verification failed for ${componentName}`);
    }
  }
}
```

#### æ¢å¤ç­–ç•¥
```typescript
// src/core/monitoring/strategies/McpServerRecoveryStrategy.ts
export class McpServerRecoveryStrategy implements RecoveryStrategy {
  private mcpServer: McpServer;
  
  constructor(mcpServer: McpServer) {
    this.mcpServer = mcpServer;
  }
  
  async recover(status: ComponentHealth['status']): Promise<void> {
    switch (status) {
      case 'degraded':
        await this.restartGracefully();
        break;
      case 'unhealthy':
        await this.forceRestart();
        break;
    }
  }
  
  private async restartGracefully() {
    console.log('Gracefully restarting MCP server...');
    
    // åœæ­¢æ¥å—æ–°è¿æ¥
    await this.mcpServer.stopAcceptingConnections();
    
    // ç­‰å¾…ç°æœ‰è¯·æ±‚å®Œæˆ
    await this.waitForRequestsToComplete(30000); // 30ç§’è¶…æ—¶
    
    // é‡å¯æœåŠ¡
    await this.mcpServer.restart();
    
    console.log('MCP server restarted gracefully');
  }
  
  private async forceRestart() {
    console.log('Force restarting MCP server...');
    
    // ç«‹å³åœæ­¢æœåŠ¡
    await this.mcpServer.forceStop();
    
    // ç­‰å¾…è¿›ç¨‹å®Œå…¨åœæ­¢
    await this.sleep(5000);
    
    // é‡å¯æœåŠ¡
    await this.mcpServer.restart();
    
    console.log('MCP server force restarted');
  }
  
  private async waitForRequestsToComplete(timeout: number): Promise<void> {
    const startTime = Date.now();
    
    while (Date.now() - startTime < timeout) {
      const activeRequests = await this.mcpServer.getActiveRequests();
      if (activeRequests === 0) {
        return;
      }
      await this.sleep(1000);
    }
    
    throw new Error('Timeout waiting for requests to complete');
  }
  
  private async sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

## âš™ï¸ é…ç½®

### ç›‘æ§é…ç½®
```typescript
// src/config/monitoring.config.ts
export interface MonitoringConfig {
  enabled: boolean;
  healthCheck: {
    interval: number;        // å¥åº·æ£€æŸ¥é—´éš”ï¼ˆæ¯«ç§’ï¼‰
    timeout: number;         // å¥åº·æ£€æŸ¥è¶…æ—¶ï¼ˆæ¯«ç§’ï¼‰
    retries: number;        // é‡è¯•æ¬¡æ•°
  };
  metrics: {
    enabled: boolean;
    collectionInterval: number;  // æŒ‡æ ‡æ”¶é›†é—´éš”ï¼ˆæ¯«ç§’ï¼‰
    retentionDays: number;       // æŒ‡æ ‡ä¿ç•™å¤©æ•°
    prometheus: {
      enabled: boolean;
      port: number;
      path: string;
    };
  };
  alerts: {
    enabled: boolean;
    channels: {
      email: {
        enabled: boolean;
        smtp: {
          host: string;
          port: number;
          secure: boolean;
          auth: {
            user: string;
            pass: string;
          };
        };
      };
      slack: {
        enabled: boolean;
        webhook: string;
        channel: string;
      };
    };
  };
  recovery: {
    enabled: boolean;
    maxAttempts: number;     // æœ€å¤§æ¢å¤å°è¯•æ¬¡æ•°
    backoffMultiplier: number; // é€€é¿å€æ•°
    maxBackoffTime: number;   // æœ€å¤§é€€é¿æ—¶é—´
  };
}

const defaultConfig: MonitoringConfig = {
  enabled: true,
  healthCheck: {
    interval: 30000,    // 30ç§’
    timeout: 5000,      // 5ç§’
    retries: 3
  },
  metrics: {
    enabled: true,
    collectionInterval: 10000,  // 10ç§’
    retentionDays: 30,
    prometheus: {
      enabled: true,
      port: 9090,
      path: '/metrics'
    }
  },
  alerts: {
    enabled: true,
    channels: {
      email: {
        enabled: false,
        smtp: {
          host: 'smtp.gmail.com',
          port: 587,
          secure: false,
          auth: {
            user: process.env.EMAIL_USER,
            pass: process.env.EMAIL_PASS
          }
        }
      },
      slack: {
        enabled: false,
        webhook: process.env.SLACK_WEBHOOK,
        channel: '#alerts'
      }
    }
  },
  recovery: {
    enabled: true,
    maxAttempts: 3,
    backoffMultiplier: 2,
    maxBackoffTime: 300000  // 5åˆ†é’Ÿ
  }
};
```

### å‘Šè­¦è§„åˆ™é…ç½®
```typescript
// src/config/alert-rules.config.ts
export interface AlertRule {
  id: string;
  name: string;
  description: string;
  condition: AlertCondition;
  severity: 'low' | 'medium' | 'high' | 'critical';
  duration: number;        // æŒç»­æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
  enabled: boolean;
  notifications: {
    channels: ('email' | 'slack' | 'webhook')[];
    recipients: string[];
  };
}

export interface AlertCondition {
  metric: string;
  operator: 'gt' | 'lt' | 'eq' | 'ne';
  threshold: number;
  labels?: Record<string, string>;
}

const alertRules: AlertRule[] = [
  {
    id: 'cpu-usage-high',
    name: 'CPU Usage High',
    description: 'CPU usage is above 80%',
    condition: {
      metric: 'system_cpu_usage_percent',
      operator: 'gt',
      threshold: 80
    },
    severity: 'high',
    duration: 300000,  // 5åˆ†é’Ÿ
    enabled: true,
    notifications: {
      channels: ['email', 'slack'],
      recipients: ['admin@example.com']
    }
  },
  {
    id: 'memory-usage-high',
    name: 'Memory Usage High',
    description: 'Memory usage is above 85%',
    condition: {
      metric: 'system_memory_usage_percent',
      operator: 'gt',
      threshold: 85
    },
    severity: 'high',
    duration: 300000,  // 5åˆ†é’Ÿ
    enabled: true,
    notifications: {
      channels: ['email', 'slack'],
      recipients: ['admin@example.com']
    }
  },
  {
    id: 'mcp-response-time-high',
    name: 'MCP Response Time High',
    description: 'MCP server response time is above 1 second',
    condition: {
      metric: 'mcp_request_duration_seconds',
      operator: 'gt',
      threshold: 1,
      labels: { method: 'checkConstraints' }
    },
    severity: 'medium',
    duration: 180000,  // 3åˆ†é’Ÿ
    enabled: true,
    notifications: {
      channels: ['slack'],
      recipients: ['#dev-alerts']
    }
  }
];
```

## ğŸ“Š ç›‘æ§ä»ªè¡¨æ¿

### Grafanaä»ªè¡¨æ¿é…ç½®

```json
{
  "dashboard": {
    "title": "DSGS System Monitoring",
    "panels": [
      {
        "title": "System Health",
        "type": "stat",
        "targets": [
          {
            "expr": "dsgs_system_health_status",
            "legendFormat": "{{status}}"
          }
        ]
      },
      {
        "title": "CPU Usage",
        "type": "graph",
        "targets": [
          {
            "expr": "system_cpu_usage_percent",
            "legendFormat": "CPU Usage"
          }
        ]
      },
      {
        "title": "Memory Usage",
        "type": "graph",
        "targets": [
          {
            "expr": "system_memory_usage_percent",
            "legendFormat": "Memory Usage"
          }
        ]
      },
      {
        "title": "MCP Request Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(mcp_requests_total[5m])",
            "legendFormat": "{{method}} {{status}}"
          }
        ]
      },
      {
        "title": "Constraint Generation Time",
        "type": "graph",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, constraint_generation_duration_bucket)",
            "legendFormat": "95th percentile"
          },
          {
            "expr": "histogram_quantile(0.50, constraint_generation_duration_bucket)",
            "legendFormat": "50th percentile"
          }
        ]
      }
    ]
  }
}
```

## ğŸ§ª æµ‹è¯•

### å•å…ƒæµ‹è¯•
```typescript
// src/test/monitoring/HealthCheckService.spec.ts
describe('HealthCheckService', () => {
  let healthCheckService: HealthCheckService;
  let mockMetricsCollector: MetricsCollector;
  
  beforeEach(() => {
    mockMetricsCollector = createMock<MetricsCollector>();
    healthCheckService = new HealthCheckService();
  });
  
  it('should return system health status', async () => {
    const health = await healthCheckService.getSystemHealth();
    
    expect(health.status).toBeOneOf(['healthy', 'degraded', 'unhealthy']);
    expect(health.timestamp).toBeDefined();
    expect(health.components).toHaveLength(4);
  });
  
  it('should detect unhealthy component', async () => {
    // æ¨¡æ‹Ÿä¸å¥åº·çš„ç»„ä»¶
    jest.spyOn(healthCheckService['components'].get('mcpServer')!, 'check')
      .mockResolvedValue({
        name: 'mcpServer',
        status: 'unhealthy',
        details: 'Connection failed',
        lastCheck: new Date().toISOString()
      });
    
    const health = await healthCheckService.getSystemHealth();
    
    expect(health.status).toBe('unhealthy');
    expect(health.components.find(c => c.name === 'mcpServer')?.status)
      .toBe('unhealthy');
  });
});
```

### é›†æˆæµ‹è¯•
```typescript
// src/test/monitoring/MonitoringIntegration.spec.ts
describe('Monitoring Integration', () => {
  let app: Application;
  let metricsCollector: MetricsCollector;
  
  beforeAll(async () => {
    app = await createTestApp();
    metricsCollector = app.get(MetricsCollector);
  });
  
  it('should collect MCP request metrics', async () => {
    // æ¨¡æ‹ŸMCPè¯·æ±‚
    await request(app.getHttpServer())
      .post('/mcp')
      .send({
        method: 'checkConstraints',
        params: { tccPath: 'test.tcc', specPath: 'test.json' }
      });
    
    // éªŒè¯æŒ‡æ ‡è¢«æ”¶é›†
    const metrics = await metricsCollector.getMetrics();
    expect(metrics.get('mcp_requests_total')).toBeDefined();
  });
  
  it('should trigger alert on unhealthy component', async () => {
    // æ¨¡æ‹Ÿä¸å¥åº·çŠ¶æ€
    await metricsCollector.recordComponentHealth('mcpServer', 'unhealthy');
    
    // éªŒè¯å‘Šè­¦è¢«è§¦å‘
    const alerts = await app.get(AlertService).getActiveAlerts();
    expect(alerts.some(a => a.component === 'mcpServer')).toBe(true);
  });
});
```

## ğŸ”— ç›¸å…³æ–‡æ¡£

### æ ¸å¿ƒæ–‡æ¡£
- [ç³»ç»Ÿæ¶æ„æ€»è§ˆ](../architecture/overview.md) - ç³»ç»Ÿæ•´ä½“æ¶æ„
- [APIå¥‘çº¦æ€»è§ˆ](../api/contract-overview.md) - APIæ¥å£å¥‘çº¦
- [æ•°æ®æ¨¡å‹å­—å…¸](../data-models/dictionary.md) - æ•°æ®ç»“æ„å®šä¹‰

### ç›¸å…³æ¨¡å—
- [å¥‘çº¦ç®¡ç†æ¨¡å—](../contract/README.md) - å¥‘çº¦ç”Ÿæˆå’ŒéªŒè¯
- [çº¦æŸç”Ÿæˆæ¨¡å—](../constraint/README.md) - åŠ¨æ€çº¦æŸç”Ÿæˆ
- [MCPåè®®æ¨¡å—](../mcp/README.md) - MCPåè®®å®ç°

### è§„èŒƒæ–‡æ¡£
- [å‘½åè§„èŒƒ](../standards/naming-conventions.md) - ç»Ÿä¸€å‘½åè§„èŒƒ
- [é”™è¯¯å¤„ç†](../standards/error-handling.md) - é”™è¯¯å¤„ç†æœºåˆ¶
- [ç‰ˆæœ¬ç®¡ç†](../standards/versioning.md) - ç‰ˆæœ¬å…¼å®¹æ€§ç®¡ç†

---

**æ¨¡å—ç»´æŠ¤**ï¼šDSGSç›‘æ§å›¢é˜Ÿ  
**æœ€åæ›´æ–°**ï¼š2025-08-06  
**ç‰ˆæœ¬**ï¼š2.0