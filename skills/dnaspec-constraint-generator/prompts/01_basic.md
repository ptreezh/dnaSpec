# 约束生成 - 基础应用

## 在00_context基础上扩展

已理解：约束定义、类型、层次、SMART原则

本层目标：掌握常见场景的约束生成方法

---

## 常见约束类型

### 1. 功能约束

**定义**：系统必须实现的功能要求

**示例**：
```yaml
用户认证:
  约束: "系统必须支持用户注册、登录、登出"
  验证: "通过测试用例验证每个功能"

数据持久化:
  约束: "所有用户数据必须持久化存储"
  验证: "检查数据库操作"
```

**实践指南**：
- 使用"必须"（MUST）描述关键功能
- 使用"应该"（SHOULD）描述次要功能
- 明确输入和输出

### 2. 性能约束

**定义**：系统的性能要求

**关键指标**：
```yaml
响应时间:
  - API响应时间 < 200ms (P95)
  - 页面加载时间 < 2s (P95)
  - 数据库查询 < 100ms (平均)

吞吐量:
  - 支持1000 QPS
  - 并发用户数 > 500

资源使用:
  - 内存使用 < 2GB
  - CPU使用 < 70%
```

**验证方法**：
- 性能测试（JMeter, Locust）
- Profiling工具
- 监控系统

### 3. 安全约束

**定义**：系统必须满足的安全要求

**常见约束**：
```yaml
认证:
  - 密码最少8位，包含大小写字母、数字、特殊字符
  - 登录失败5次后锁定账户30分钟
  - 会话超时时间：30分钟

授权:
  - 基于角色的访问控制（RBAC）
  - API需要token验证
  - 敏感操作需要二次验证

数据保护:
  - 密码使用bcrypt加密（cost=12）
  - 敏感数据加密存储（AES-256）
  - HTTPS传输
```

**验证方法**：
- 安全扫描（OWASP ZAP）
- 渗透测试
- 代码审查

### 4. 可用性约束

**定义**：系统可用性要求

**示例**：
```yaml
可用性:
  - 系统可用性 > 99.9%（月度）
  - 计划内维护窗口：每周日2:00-4:00 AM
  - RTO（恢复时间目标）：< 1小时
  - RPO（恢复点目标）：< 5分钟

容错:
  - 关键服务多实例部署
  - 数据库主从复制
  - 故障自动切换
```

### 5. 技术约束

**定义**：技术选型和架构约束

**示例**：
```yaml
语言和框架:
  - 后端：Python 3.9+ / FastAPI
  - 前端：TypeScript / React 18
  - 数据库：PostgreSQL 14+

架构模式:
  - RESTful API设计
  - MVC架构模式
  - 依赖注入

外部依赖:
  - 仅使用维护中的开源库
  - 避免使用GPL许可证的代码
```

---

## 约束生成工作流

### Step 1：收集需求

**信息来源**：
- 用户需求文档
- 业务规则
- 技术规范
- 合规要求

**问题清单**：
- 系统需要解决什么问题？
- 用户的核心需求是什么？
- 有什么性能要求？
- 有什么安全顾虑？
- 有什么技术限制？

### Step 2：分类约束

**分类标准**：
```yaml
功能约束:
  source: "用户故事、用例"
  priority: "高"

非功能约束:
  source: "性能、安全、可用性要求"
  priority: "中高"

技术约束:
  source: "技术栈、架构决策"
  priority: "中"

业务约束:
  source: "合规、预算、时间"
  priority: "可变"
```

### Step 3：应用SMART原则

**示例**：
```
❌ 模糊约束：
"系统应该快速响应"

✅ SMART约束：
"API P95响应时间 < 200ms"
- Specific：API响应时间
- Measurable：200ms可测量
- Achievable：技术可行
- Relevant：影响用户体验
- Time-bound：P95持续达标
```

### Step 4：定义验证方法

**验证矩阵**：
```yaml
约束类型 → 验证方法：

功能约束 → 单元测试、集成测试
性能约束 → 性能测试、负载测试
安全约束 → 安全扫描、渗透测试
可用性约束 → 故障注入、灾备测试
技术约束 → 代码审查、静态分析
```

### Step 5：优先级排序

**优先级框架**：
```yaml
P0 - 关键（Critical）:
  - 影响系统核心功能
  - 涉及安全或合规
  - 阻止系统上线

P1 - 高（High）:
  - 严重影响用户体验
  - 业务关键需求

P2 - 中（Medium）:
  - 改进性需求
  - 长期优化目标

P3 - 低（Low）:
  - 锦上添花的功能
  - 可以延后实现
```

---

## 实践案例

### 案例：电商API性能约束

**需求**："API需要快速"

**转化为约束**：
```yaml
约束定义:
  - P95响应时间 < 200ms
  - P99响应时间 < 500ms
  - 支持1000 QPS
  - 并发用户数 > 500

验证方法:
  - 使用Locust进行负载测试
  - 持续监控API响应时间
  - 每周性能报告

验收标准:
  - 性能测试通过率 > 95%
  - 生产环境监控达标
```

### 案例：用户数据安全约束

**需求**："保护用户数据"

**转化为约束**：
```yaml
约束定义:
  - 密码使用bcrypt加密（cost=12）
  - 敏感数据AES-256加密
  - 强制HTTPS传输
  - 日志不记录敏感信息

验证方法:
  - 安全扫描（OWASP ZAP）
  - 代码审查安全检查
  - 渗透测试（季度）

验收标准:
  - 安全扫描无高危漏洞
  - 渗透测试报告通过
```

---

## 常见错误

### 错误1：约束过于模糊

**❌ 错误**："系统应该快速"

**✅ 正确**："API P95响应时间 < 200ms"

### 错误2：约束无法验证

**❌ 错误**："代码质量要高"

**✅ 正确**："单元测试覆盖率 > 80%，代码复杂度 < 10"

### 错误3：约束冲突

**❌ 错误**：
- "成本最低"
- "性能最高"

**✅ 正确**：
- "在预算范围内优化性能"
- "性能目标：P95 < 200ms"

### 错误4：约束过多

**问题**：100个约束，无法管理

**解决**：
- P0-P3优先级分类
- 聚焦关键约束（P0, P1）
- 延后次要约束

---

## 质量检查

**约束质量检查清单**：
- [ ] 具体明确（Specific）
- [ ] 可测量（Measurable）
- [ ] 可实现（Achievable）
- [ ] 相关性（Relevant）
- [ ] 有时限（Time-bound）
- [ ] 有验证方法
- [ ] 有优先级
- [ ] 无冲突矛盾

---

*本层覆盖常见约束类型和生成方法（约1000字符）*
