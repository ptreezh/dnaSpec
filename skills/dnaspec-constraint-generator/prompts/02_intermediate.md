# 约束生成 - 中级场景

## 约束依赖管理

### 识别约束依赖

某些约束依赖于其他约束的实现。

**示例**：
```yaml
约束链:
  A: "API响应时间 < 200ms"
    ↓ 依赖于
  B: "数据库查询 < 50ms"
    ↓ 依赖于
  C: "使用索引优化"

管理策略：
  - 绘制依赖图
  - 识别关键路径
  - 并行验证无依赖约束
```

### 解决约束冲突

**冲突类型**：
```yaml
性能 vs 安全:
  - 冲突：加密影响性能
  - 解决：异步加密、硬件加速

成本 vs 质量:
  - 冲突：高质量高成本
  - 解决：MVP策略、分阶段实现

速度 vs 稳定性:
  - 冲突：快迭代可能不稳定
  - 解决：灰度发布、快速回滚
```

---

## 约束验证策略

### 自动化验证

**单元测试层**：
```python
def test_response_time_constraint():
    """验证响应时间约束"""
    response = api_call()
    assert response.elapsed < 0.2  # 200ms
```

**集成测试层**：
```python
def test_security_constraints():
    """验证安全约束"""
    response = login("weak_password")
    assert response.status_code == 400
```

### 持续监控

**监控指标**：
```yaml
性能监控:
  - API响应时间（P50/P95/P99）
  - 数据库查询时间
  - 缓存命中率

安全监控:
  - 登录失败次数
  - 异常API调用
  - 数据访问模式
```

---

## 约束版本管理

### 约束演化

**版本策略**：
```yaml
v1.0 (MVP):
  - 核心功能约束
  - 基本性能约束

v2.0 (增长):
  - 扩展功能约束
  - 性能提升约束

v3.0 (成熟):
  - 完整约束体系
  - 优化性能约束
```

### 向后兼容性

**原则**：
- 新约束不能破坏现有功能
- 宽约束变严需要迁移期
- 废弃约束需要提前通知

---

*本层覆盖约束依赖管理、验证策略和版本管理*
