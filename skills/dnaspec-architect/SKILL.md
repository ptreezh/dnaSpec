---
name: dnaspec-architect
description: Design architecture supporting intelligent agent integration with focus on scalability, modularity, and multi-layer call alignment. Prevent architecture chaos. When designing complex systems, microservices, event-driven architecture, or multi-agent systems, use this skill.
---

# DNASPEC Architect

## 使用时机

当用户提到以下需求时，使用此技能：
- "架构设计" 或 "architecture design"
- "系统规划" 或 "system planning"
- "项目架构" 或 "project architecture"
- "分层设计" 或 "layered design"
- "微服务架构" 或 "microservices"
- "智能体系统" 或 "agent system"
- "多层级调用" 或 "multi-layer calls"
- "防止架构失控" 或 "prevent architecture chaos"
- 复杂项目的整体架构
- 需要智能体集成的系统

**不要在以下情况使用**：
- ❌ 讨论具体代码实现
- ❌ 解决具体的编程问题
- ❌ 优化算法或数据结构
- ❌ 调试代码错误

## 核心理念

### 🎯 多层级调用对齐（Multi-Layer Call Alignment）

**什么是多层级调用对齐？**

在多层系统中，确保跨层级调用的协议、格式、错误处理、超时设置等保持一致。

```
❌ 未对齐的多层调用：

前端 → API Gateway
  ├─ 调用格式：REST/JSON
  ├─ 错误处理：HTTP状态码
  └─ 超时：30秒

API Gateway → 业务服务层
  ├─ 调用格式：gRPC/Protobuf  ← 不一致！
  ├─ 错误处理：抛出异常      ← 不一致！
  └─ 超时：60秒              ← 不一致！

业务服务层 → 数据访问层
  ├─ 调用格式：REST/JSON     ← 又不一致！
  ├─ 错误处理：返回error字段 ← 不一致！
  └─ 超时：无限制            ← 不一致！

→ 问题：协议不一致、错误处理不一致、超时策略混乱
→ 结果：难以调试、性能问题、错误传播不可预测
```

```
✅ 对齐后的多层调用：

前端 → API Gateway
  ├─ 调用格式：REST/JSON
  ├─ 错误处理：HTTP状态码 + 标准错误体
  ├─ 超时：30秒
  └─ 重试：指数退避，最多3次

API Gateway → 业务服务层
  ├─ 调用格式：REST/JSON     ← 对齐！
  ├─ 错误处理：HTTP状态码    ← 对齐！
  ├─ 超时：20秒             ← 对齐（逐级递减）
  └─ 重试：指数退避，最多2次 ← 对齐

业务服务层 → 数据访问层
  ├─ 调用格式：REST/JSON     ← 对齐！
  ├─ 错误处理：HTTP状态码    ← 对齐！
  ├─ 超时：10秒             ← 对齐（逐级递减）
  └─ 重试：指数退避，最多1次 ← 对齐

→ 协议一致、错误处理统一、超时策略清晰
→ 易于调试、性能可控、错误传播可预测
```

**多层级调用对齐的要素**：

**1. 协议对齐**
```yaml
protocol_alignment:
  format: 统一使用REST/JSON或统一使用gRPC
  versioning: API版本管理（v1, v2, v3）
  authentication: 统一的认证机制（JWT/OAuth2）
  serialization: 统一的数据格式（JSON/Protobuf）
```

**2. 错误处理对齐**
```yaml
error_handling_alignment:
  format: 统一的错误响应格式
  codes: 统一的错误码体系
  propagation: 统一的错误传播机制
  recovery: 统一的降级策略

example:
  all_layers_use:
    format: { "error": "ERROR_TYPE", "message": "...", "code": 400 }
    propagation: 逐层传递，不吞没错误
    recovery: 熔断 → 降级 → 返回默认值
```

**3. 超时设置对齐**
```yaml
timeout_alignment:
  strategy: 逐级递减（外层 > 中层 > 内层）
  example:
    layer_1: 30秒
    layer_2: 20秒
    layer_3: 10秒
  rationale: 确保总超时时间可控
```

**4. 重试策略对齐**
```yaml
retry_alignment:
  all_layers_use:
    max_attempts: 3次（外层）、2次（中层）、1次（内层）
    backoff: 指数退避（2^n 秒）
    retryable_errors: 只重试可恢复错误（5xx, timeout）
```

### 🎯 防止架构失控（Preventing Architecture Chaos）

**什么是架构失控？**

架构失控是指系统演化过程中出现：
- 模块边界模糊
- 职责不清晰
- 耦合度增加
- 接口不统一
- 技术债务累积

**失控的演化路径**：

```
阶段1：清晰的架构
├─ 模块边界清晰
├─ 职责明确
├─ 接口统一
└─ 耦合度低

↓ 缺少监控和控制

阶段2：轻微混乱
├─ 模块间出现循环依赖
├─ 职责开始模糊
├─ 接口风格不一致
└─ 耦合度增加

↓ 继续失控

阶段3：架构失控
├─ 模块边界完全模糊
├─ "面条代码"架构
├─ 接口五花八门
└─ 牵一发动全身
```

**防止架构失控的措施**：

**措施1：架构审查机制**
```yaml
architecture_review:
  frequency: 每个版本
  checklist:
    - 模块边界是否清晰？
    - 职责是否单一？
    - 接口是否统一？
    - 耦合度是否增加？
  action:
    - 发现问题立即整改
    - 阻止架构恶化
```

**措施2：模块化强制约束**
```yaml
modularity_constraints:
  boundaries:
    - 禁止循环依赖
    - 强制单向依赖
    - 接口隔离原则

  enforcement:
    - 使用依赖分析工具
    - CI/CD中检查依赖
    - 架构守卫测试
```

**措施3：接口版本管理**
```yaml
interface_management:
  versioning:
    - 语义化版本（SemVer）
    - 向后兼容性检查
    - 废弃API公告期

  standardization:
    - 统一接口规范
    - 自动化文档生成
    - 契约测试
```

**措施4：技术债务管理**
```yaml
technical_debt_management:
  tracking:
    - 记录所有架构妥协
    - 评估债务影响
    - 设定偿还计划

  limits:
    - 设定技术债务上限
    - 超过上限暂停新功能
    - 强制偿还周期
```

### 🎯 智能体集成架构

**智能体系统的特殊挑战**：

```
传统系统架构：
用户 → 前端 → 后端 → 数据库
      ↓
   静态架构，组件固定

智能体系统架构：
用户 → 主协调器 → 局部智能体A
                → 局部智能体B
                → 局部智能体C
      ↓
   动态架构，智能体可增减
```

**智能体集成的关键考虑**：

**1. 智能体隔离**
```yaml
agent_isolation:
  context: 每个智能体有独立的局部上下文
  workspace: 独立的工作区目录
  communication: 通过接口，不直接访问上下文
  failure: 单个智能体失败不影响其他智能体
```

**2. 智能体协调**
```yaml
agent_coordination:
  orchestrator: 轻量级主协调器
  pattern: 编排器模式（Orchestrator Pattern）

  communication:
    protocol: REST API
    format: JSON
    schema: 统一的消息schema

  discovery: 服务发现机制
  load_balancing: 智能体负载均衡
```

**3. 智能体可观测性**
```yaml
agent_observability:
  logging: 统一的日志格式
  monitoring: 每个智能体的性能指标
  tracing: 分布式链路追踪
  alerting: 异常告警机制
```

### 🎯 格式塔认知原则在架构设计中的应用

**整体性原则（Whole > Sum of Parts）**：

```
❌ 孤立设计各层：
接入层设计 → 完美 ✅
应用层设计 → 完美 ✅
数据层设计 → 完美 ✅

集成测试：失败 ❌

问题：各层独立设计，没有整体考虑

✅ 从整体到局部：
先定义整体架构（系统级蓝图）
  ↓
再设计各层细节
  ↓
确保各层协调一致
  ↓
集成测试：通过 ✅
```

**从简单到复杂演化**：

```
演化路径：

阶段1：最简架构（MVP）
├─ 单体应用
├─ 单数据库
└─ 少量用户
→ 整体简单，但完整

↓ 遵循格式塔原则：逐步演化

阶段2：分层架构
├─ 继承阶段1
├─ 前后端分离
├─ 引入缓存
└─ 更多用户
→ 增加复杂度，但保持整体协调

↓ 继续演化

阶段3：微服务架构
├─ 继承阶段2
├─ 服务拆分
├─ 消息队列
└─ 大量用户
→ 高度复杂，但架构清晰

关键：每个阶段都是一个"整体"，不是零散功能的堆砌
```

---

## 全生命周期应用

### 📋 Idea阶段：为概念设计初始架构

**场景**：用户有一个模糊的想法，需要设计初始架构

**示例**：
```
用户想法："我想做一个AI代码助手"

架构设计：
📋 需求理解
- 核心功能：AI辅助代码编写
- 目标用户：开发者
- 技术约束：需要集成AI模型

🎯 初始架构（最简整体）
┌─────────────────────────┐
│   Web界面（前端）        │
├─────────────────────────┤
│   后端服务              │
│   ├─ 代码分析           │
│   └─ AI集成            │
├─────────────────────────┤
│   AI模型服务           │
└─────────────────────────┘

✅ 格式塔原则：简单但完整的整体
- 前端、后端、AI服务三层
- 每层职责清晰
- 接口简单统一

📋 防止架构失控
- 明确模块边界
- 定义接口规范
- 建立架构审查机制
```

**使用技能**：
```
/dnaspec.architect "AI代码助手概念架构"
→ 设计最简整体架构
→ 定义模块边界
→ 建立接口规范
→ 确保从简单开始
```

### 📋 需求阶段：设计支持智能体集成的架构

**场景**：有完整的需求，需要设计支持智能体集成的系统架构

**示例**：
```
需求：设计电商平台，支持10万并发

架构设计：
📋 系统架构设计
┌─────────────────────────┐
│   API Gateway          │  统一入口、认证、限流
├─────────────────────────┤
│   业务服务层            │
│   ├─ 用户服务           │
│   ├─ 商品服务           │
│   ├─ 订单服务           │
│   └─ 支付服务           │
├─────────────────────────┤
│   智能体层              │  ← 智能体集成
│   ├─ 推荐智能体         │
│   ├─ 客服智能体         │
│   └─ 分析智能体         │
├─────────────────────────┤
│   数据层                │
│   ├─ PostgreSQL         │
│   ├─ Redis              │
│   └─ Elasticsearch      │
└─────────────────────────┘

🎯 多层级调用对齐
API Gateway → 业务服务 → 智能体 → 数据服务
    ├─ 协议：REST/JSON（统一）
    ├─ 错误：标准错误体（统一）
    ├─ 超时：30s → 20s → 10s（递减）
    └─ 重试：3次 → 2次 → 1次（递减）

📋 智能体集成设计
智能体隔离：
  ├─ 推荐智能体：独立的推荐上下文
  ├─ 客服智能体：独立的客服上下文
  └─ 分析智能体：独立的分析上下文

智能体协调：
  ├─ 主协调器：轻量级任务分发
  ├─ 通信协议：REST API
  └─ 消息格式：统一JSON schema

📋 防止架构失控
架构审查：
  ✅ 模块边界清晰
  ✅ 接口统一规范
  ✅ 无循环依赖
  ✅ 耦合度低

技术债务管理：
  ✅ 记录架构妥协
  ✅ 设定偿还计划
  ✅ 定期架构审查
```

**使用技能**：
```
/dnaspec.architect "电商平台架构设计"
→ 设计分层架构
→ 对齐多层级调用
→ 集成智能体系统
→ 防止架构失控
```

### 📋 细化阶段：细化模块间接口对齐

**场景**：功能细化时，需要确保模块间接口对齐

**示例**：
```
细化需求：支付流程需要对接多个支付网关

架构细化：
📋 多层级接口对齐

层级1：API Gateway → 支付服务
├─ 接口：POST /api/payment/pay
├─ 请求：{ "orderId": "...", "amount": 100, "method": "alipay" }
├─ 响应：{ "status": "pending", "paymentId": "..." }
├─ 错误：{ "error": "PAYMENT_ERROR", "message": "..." }
├─ 超时：20秒
└─ 重试：2次

层级2：支付服务 → 支付网关适配器
├─ 接口：POST /payment/{method}/charge
├─ 请求：{ "orderId": "...", "amount": 100 }
├─ 响应：{ "status": "success", "transactionId": "..." }
├─ 错误：{ "error": "GATEWAY_ERROR", "message": "..." }  ← 对齐错误格式
├─ 超时：15秒  ← 对齐（递减）
└─ 重试：1次  ← 对齐（递减）

层级3：支付网关适配器 → 第三方支付
├─ 支付宝适配器
├─ 微信支付适配器
├─ 银联适配器
└─ 统一接口：PaymentGatewayAdapter

✅ 多层级对齐验证
- 协议：REST/JSON ✅
- 错误格式：统一 ✅
- 超时：20s → 15s → 10s ✅
- 重试：2次 → 1次 → 0次 ✅

📋 防止架构失控
模块边界：
  ✅ 支付服务：业务逻辑
  ✅ 适配器：协议转换
  ✅ 第三方支付：外部依赖

依赖检查：
  ✅ 无循环依赖
  ✅ 单向依赖流
  ✅ 接口稳定
```

**使用技能**：
```
/dnaspec.architect "支付流程架构细化"
→ 对齐多层级接口
→ 统一错误处理
→ 验证超时策略
→ 确保模块边界清晰
```

### 📋 智能阶段：智能体协作架构

**场景**：需要多个智能体协作完成复杂任务

**示例**：
```
智能体系统：项目健康检查

架构设计：
🏗️ 智能体协作架构

主协调器（ProjectHealthCoordinator）
├─ 工作区：coordinators/project-health/
├─ 上下文：最小化（只包含协调信息）
└─ 职责：任务分发、结果聚合、错误处理

├─ 局部智能体1：CodeQualityAgent
│   ├─ 工作区：agents/code-quality/
│   ├─ 上下文：只包含代码质量规则（2000 tokens）
│   ├─ 接口：POST /api/agents/code-quality/check
│   └─ 输出：{ "score": 0.82, "issues": [...] }

├─ 局部智能体2：TestCoverageAgent
│   ├─ 工作区：agents/test-coverage/
│   ├─ 上下文：只包含测试覆盖率标准（1500 tokens）
│   ├─ 接口：POST /api/agents/test-coverage/check  ← 对齐接口格式
│   └─ 输出：{ "score": 0.65, "coverage": {...} }

└─ 局部智能体3：DependencyHealthAgent
    ├─ 工作区：agents/dependency-health/
    ├─ 上下文：只包含依赖检查规则（1800 tokens）
    ├─ 接口：POST /api/agents/dependency-health/check  ← 对齐接口格式
    └─ 输出：{ "score": 0.90, "dependencies": [...] }

🎯 多层级调用对齐

协调器 → 智能体
├─ 协议：REST/JSON（统一） ✅
├─ 接口格式：POST /api/agents/{agent-name}/check（统一） ✅
├─ 请求格式：{ "projectPath": "..." }（统一） ✅
├─ 响应格式：{ "score": 0.0-1.0, "details": {...} }（统一） ✅
├─ 错误格式：{ "error": "...", "message": "..." }（统一） ✅
├─ 超时：30秒（协调器） → 10秒（各智能体） ✅
└─ 重试：1次（统一） ✅

📋 智能体隔离
- 每个智能体独立的上下文工作区
- 通过接口通信，不直接访问上下文
- 单个智能体失败不影响其他智能体
- 主协调器负责错误处理和降级

📋 防止架构失控
架构审查：
  ✅ 智能体职责单一明确
  ✅ 接口统一规范
  ✅ 无智能体间直接依赖
  ✅ 主协调器轻量化

可观测性：
  ✅ 统一日志格式
  ✅ 分布式链路追踪
  ✅ 性能指标监控
  ✅ 异常告警机制
```

**使用技能**：
```
/dnaspec.architect "智能体协作架构"
→ 设计主协调器
→ 定义局部智能体
→ 对齐智能体接口
→ 确保上下文隔离
```

---

## 核心功能

### 1. 需求分析与架构设计

**分析维度**：
1. **业务需求**
   - 核心业务目标
   - 目标用户群体
   - 业务场景分析
   - 业务规则

2. **技术需求**
   - 性能要求（QPS、响应时间、并发）
   - 可用性要求（SLA、容错）
   - 扩展性要求（水平/垂直扩展）
   - 安全性要求（认证、授权、加密）

3. **智能体集成需求**
   - 需要哪些智能体？
   - 智能体如何协作？
   - 上下文如何隔离？
   - 接口如何对齐？

**输出**：需求分析报告 + 初始架构设计

### 2. 架构模式选择

**常见架构模式**：

1. **单体架构 (Monolithic)**
   - 适用: 小型项目、快速原型
   - 优势: 开发简单、部署方便
   - 劣势: 扩展困难、耦合度高

2. **分层架构 (Layered)**
   - 适用: 中小型项目
   - 优势: 职责清晰、易于理解
   - 劣势: 层间可能冗余

3. **微服务架构 (Microservices)**
   - 适用: 大型复杂系统
   - 优势: 独立部署、技术异构
   - 劣势: 运维复杂、分布式事务

4. **事件驱动架构 (Event-Driven)**
   - 适用: 高并发、松耦合
   - 优势: 异步处理、解耦
   - 劣势: 一致性难保证

5. **多智能体系统 (Multi-Agent System)**
   - 适用: 需要智能体协作
   - 优势: 局部上下文、独立扩展
   - 劣势: 协调复杂、接口对齐

### 3. 多层级调用对齐设计

**对齐要素**：
- **协议对齐**：REST/JSON或gRPC统一
- **错误处理对齐**：标准错误响应格式
- **超时设置对齐**：逐级递减策略
- **重试策略对齐**：统一的重试机制

**对齐验证**：
```yaml
alignment_checklist:
  protocol:
    - 所有层级使用相同协议
    - API版本管理一致
    - 认证机制统一

  error_handling:
    - 错误格式统一
    - 错误码体系统一
    - 错误传播机制统一

  timeout:
    - 外层超时 > 中层超时 > 内层超时
    - 总超时时间可控
    - 超时后的降级策略明确

  retry:
    - 重试次数逐级递减
    - 退避策略一致
    - 只重试可恢复错误
```

### 4. 架构失控预防

**预防措施**：
- **架构审查**：定期审查架构健康度
- **模块化约束**：强制模块边界和依赖规则
- **接口管理**：版本化和文档化
- **技术债务管理**：追踪和偿还机制

---

## 输出格式

### 架构设计文档结构

```markdown
# [项目名称] 系统架构设计

## 1. 项目概述
- 项目背景
- 业务目标
- 目标用户
- 核心价值

## 2. 需求分析
### 2.1 功能需求
### 2.2 非功能需求
- 性能要求
- 可用性要求
- 安全性要求
- 可扩展性要求
### 2.3 智能体集成需求
- 智能体列表
- 协作模式
- 隔离机制

## 3. 架构设计
### 3.1 架构模式
- 选择理由
- 架构图
- 关键决策

### 3.2 系统分层
- 接入层设计
- 应用层设计
- 领域层设计
- 数据层设计
- 智能体层设计（如果适用）

### 3.3 多层级调用对齐
- 协议对齐
- 错误处理对齐
- 超时设置对齐
- 重试策略对齐

### 3.4 服务划分
- 服务列表
- 服务边界
- 服务职责
- 服务依赖

### 3.5 数据架构
- 存储选型
- 数据模型
- 缓存策略
- 一致性方案

### 3.6 技术栈
- 后端技术栈
- 前端技术栈
- 中间件
- 工具链

## 4. 关键设计
### 4.1 API设计
### 4.2 安全设计
### 4.3 性能优化
### 4.4 监控运维

## 5. 智能体集成（如果适用）
### 5.1 智能体架构
### 5.2 接口对齐
### 5.3 协作机制
### 5.4 隔离策略

## 6. 实施计划
### 6.1 任务分解
### 6.2 优先级排序
### 6.3 里程碑规划

## 7. 架构失控预防
### 7.1 架构审查机制
### 7.2 技术债务管理
### 7.3 质量门禁

## 8. 风险与对策
### 8.1 技术风险
### 8.2 业务风险
### 8.3 资源风险
```

---

## 使用示例

### 示例1：电商平台架构设计

**用户需求**：
"设计一个支持10万并发、99.99%可用性的电商平台，技术栈是Node.js + PostgreSQL + Redis"

**架构师分析**：

📋 **需求分析**
- 业务: 电商交易平台
- 规模: 10万并发用户
- 可用性: 99.99% (年停机时间 < 53分钟)
- 技术栈: Node.js + PostgreSQL + Redis

🎯 **架构选择**
- 选择微服务架构
- 理由: 高并发要求、可独立扩展

🏗️ **系统设计**

服务划分：
- 用户服务 (用户注册、登录、Profile)
- 商品服务 (商品管理、搜索、分类)
- 订单服务 (下单、支付、物流)
- 库存服务 (库存管理、预占、扣减)
- 通知服务 (邮件、短信、推送)

分层架构：
```
API Gateway (Kong/Tyk)
    ↓
微服务层 (Node.js + Express/NestJS)
    ↓
数据层
  ├── PostgreSQL (主数据)
  ├── Redis (缓存/会话)
  └── Elasticsearch (搜索)
```

🔗 **多层级调用对齐**

API Gateway → 业务服务
- 协议：REST/JSON
- 错误：{ "error": "...", "message": "...", "code": 400 }
- 超时：30秒
- 重试：3次（指数退避）

业务服务 → 数据服务
- 协议：REST/JSON ✅ 对齐
- 错误：{ "error": "...", "message": "...", "code": 500 } ✅ 对齐
- 超时：20秒 ✅ 对齐（递减）
- 重试：2次 ✅ 对齐（递减）

---

## 质量检查清单

### 架构设计检查
- [ ] 需求分析完整
- [ ] 架构模式合理
- [ ] 技术选型有依据
- [ ] 服务边界清晰
- [ ] 数据设计完善
- [ ] 接口规范明确
- [ ] 性能可达标
- [ ] 安全有保障
- [ ] 可运维可监控
- [ ] 实施计划可行

### 多层级对齐检查
- [ ] 协议对齐
- [ ] 错误处理对齐
- [ ] 超时设置对齐
- [ ] 重试策略对齐
- [ ] 认证机制对齐

### 架构失控预防检查
- [ ] 架构审查机制建立
- [ ] 模块边界清晰
- [ ] 依赖关系单向
- [ ] 接口版本管理
- [ ] 技术债务追踪

### 智能体集成检查（如果适用）
- [ ] 智能体上下文隔离
- [ ] 接口对齐
- [ ] 协作机制明确
- [ ] 失败隔离
- [ ] 可观测性完整

---

## 协作技能

- **dnaspec-context-analysis**: 分析需求文档质量
- **dnaspec-context-optimization**: 优化架构文档
- **dnaspec-cognitive-template**: 使用思维链进行推理
- **dnaspec-task-decomposer**: 任务分解协调
- **dnaspec-agent-creator**: 智能体创建协调
- **dnaspec-constraint-generator**: 约束生成协调

---

## 关键成就

1. ✅ **多层级调用对齐** - 协议、错误、超时、重试统一对齐
2. ✅ **防止架构失控** - 架构审查、模块化约束、技术债务管理
3. ✅ **智能体集成** - 上下文隔离、接口对齐、协作机制
4. ✅ **全生命周期应用** - Idea→需求→细化→智能四阶段
5. ✅ **格式塔原则体现** - 整体性设计、从简单到复杂演化
6. ✅ **可扩展性和模块化** - 支持多种架构风格

---

*此技能专注于设计支持智能体集成的系统架构，通过多层级调用对齐和架构失控预防机制，确保系统的可扩展性、模块化和长期可维护性。*
