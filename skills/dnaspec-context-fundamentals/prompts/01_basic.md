# 上下文基础 - 基础应用层

## 在00_context基础上扩展

已理解：定义、重要性、限制、格式塔原则、失效模式

本层目标：掌握常见场景的上下文应用模式

---

## 常见场景

### 场景1：代码审查

**上下文组成**：
```
请求 + 代码 + 项目结构 + 测试结果
```

**最佳实践**：
- ✅ 包含完整函数实现
- ✅ 包含调用上下文
- ❌ 不要整个项目代码库

**容量规划**：
- 小函数（<100行）：基础上下文
- 中型模块（100-500行）：中级上下文
- 大型系统（>500行）：分解后审查

### 场景2：Bug修复

**上下文组成**：
```
描述 + 日志 + 相关代码 + 环境 + 最近改动
```

**最佳实践**：
- ✅ 优先包含错误日志和堆栈
- ✅ 包含完整调用链
- ✅ 包含最近改动（git diff）

**防毒化**：
- 明确代码版本
- 标注时间戳
- 明确优先级

### 场景3：功能开发

**上下文组成**：
```
需求 + 规范 + 现有代码 + 架构决策 + 约束
```

**最佳实践**：
- ✅ 从需求开始（最小上下文）
- ✅ 逐步添加技术细节
- ✅ 明确依赖关系
- ❌ 不要预加载全部可能相关内容

**渐进式开发**：
```
第1步：理解需求（轻量）
第2步：设计接口（添加规范）
第3步：实现核心（添加代码）
第4步：集成测试（添加依赖）
```

### 场景4：性能优化

**上下文组成**：
```
性能目标 + profiling数据 + 瓶颈分析 + 优化方案
```

**最佳实践**：
- ✅ 从profiling数据开始（事实）
- ✅ 聚焦瓶颈区域
- ✅ 对比优化前后
- ❌ 不要优化所有代码

**上下文控制**：
- 每次优化一个瓶颈
- 验证后再进入下一个
- 保持上下文聚焦

---

## 上下文模式

### 模式1：增量上下文

**适用**：需要逐步增加信息

初始请求→添加上下文→分析依赖→设计方案

**优势**：避免初始过大，支持探索，保持可控

### 模式2：分层上下文

**适用**：复杂系统设计

L1：高层架构（组件、接口）
L2：模块设计（类、函数）
L3：实现细节（算法、数据）

**优势**：每层关注抽象，支持自顶向下

### 模式3：按需上下文

**适用**：信息检索

请求→分析需求→按需加载→完成任务

**优势**：最小化大小，最大化相关性

### 模式4：隔离上下文

**适用**：多任务并行

Task1: workspace-1/（只含Task1信息）
Task2: workspace-2/（只含Task2信息）

**优势**：无干扰，可并行，易追踪

---

## 质量评估

### 快速检查

**完整性**：必需信息都提供了吗？
**相关性**：每个信息都相关吗？
**组织性**：信息结构清晰吗？
**容量**：token数量合理吗？
**一致性**：信息之间有矛盾吗？

### 量化指标

使用calculator脚本评估：

```bash
python scripts/calculator.py \
  --request "你的请求" \
  --context-file context.json
```

**输出**：
```json
{
  "token_count": 15000,
  "relevance_score": 0.85,
  "completeness_score": 0.90,
  "recommendation": "context_size_ok"
}
```

---

## 实践指导

### 上下文设计工作流

**Step 1**：明确目标（需要完成什么？需要哪些信息？）

**Step 2**：收集信息（列出可能相关信息，评估相关性）

**Step 3**：过滤组织（移除无关，按重要性排序，结构化）

**Step 4**：验证容量（估算token，确保在限制内）

**Step 5**：迭代优化（根据反馈调整，记录最佳实践）

### 常见错误修复

| 错误 | 症状 | 修复 |
|-----|------|------|
| 信息不足 | AI幻觉 | 添加必需信息 |
| 信息过多 | AI分心 | 强过滤、分批 |
| 信息无关 | AI偏离 | 相关性评分 |
| 信息混乱 | AI慢 | 结构化组织 |
| 信息矛盾 | AI犹豫 | 明确优先级 |

---

*本层覆盖常见应用场景（约1000字符）*
