---
name: dnaspec-cognitive-template
description: Apply Gestalt cognitive principles to structure complex thinking. Use templates for chain-of-thought, few-shot learning, verification, and role-playing based on principles: whole > sum of parts, simple-to-complex evolution, similarity, continuity, and closure. When structuring complex reasoning, preventing chaos, or evolving from simple to complex systems, use this skill.
---

# DNASPEC Cognitive Template

## 使用时机

当用户提到以下需求时，使用此技能：
- "分步思考" 或 "step by step"
- "举例说明" 或 "give examples"
- "验证结果" 或 "verify"
- "角色分析" 或 "role playing"
- "深入理解" 或 "understand"
- "结构化思维" 或 "structured thinking"
- "复杂任务分解" 或 "complex task breakdown"
- "从简单到复杂" 或 "simple to complex"
- 需要结构化推理
- 需要防止思维混乱
- 需要认知框架

**不要在以下情况使用**：
- ❌ 简单直接的任务（不需要模板）
- ❌ 已有明确执行步骤的任务

## 核心理念

### 🎯 格式塔认知原则（Gestalt Cognitive Principles）

**什么是格式塔原则？**

格式塔（Gestalt）是德语，意为"形状"或"形式"。格式塔心理学认为：**"整体大于部分之和"**（The whole is greater than the sum of its parts）。

**核心原则**：

#### 1. 整体性原则（Prägnanz）

**核心思想**：人类认知追求最简单的组织形式

```
❌ 混乱的认知：
"用户系统有注册、登录、密码重置、信息修改、
权限管理、角色分配、功能授权、日志记录、
安全审计、性能监控、容错处理、数据备份、
统计分析、报表生成、API接口、Web界面..."

→ 认知负担重，难以理解

✅ 结构化的认知（整体性）：
"用户系统 = 核心功能 + 扩展功能

核心功能（必需）：
- 用户认证：注册、登录
- 用户管理：信息修改、密码重置

扩展功能（增强）：
- 权限体系：角色、权限
- 系统保障：日志、监控、备份
- 数据服务：统计、报表、API"

→ 认知负担轻，易于理解
```

#### 2. 从简单到复杂演化（Evolution from Simple to Complex）

**核心思想**：系统应该从简单开始，逐步演化到复杂

```
演化路径：

阶段1：最简版本（MVP）
├─ 用户注册
├─ 用户登录
└─ 基本信息管理

↓ 遵循格式塔原则：逐步扩展

阶段2：功能增强
├─ 继承阶段1
├─ 密码重置
├─ 权限管理
└─ 操作日志

↓ 继续演化

阶段3：系统完善
├─ 继承阶段2
├─ 安全审计
├─ 性能监控
└─ 数据分析

关键：每个阶段都是一个"整体"，不是零散功能的堆砌
```

#### 3. 相似性原则（Similarity）

**核心思想**：相似的元素会被认知为一个整体

```
❌ 不相似的混乱组织：
 getUserData()
 save_to_file()
 DeleteRecord()
 PROCESS_PAYMENT()
 calc_total()

→ 认知负担重，难以记忆

✅ 相似性组织：
数据获取：
- getUserData()
- fetchRecords()
- queryData()

数据操作：
- saveToFile()
- updateRecord()
- deleteRecord()

业务处理：
- processPayment()
- calculateTotal()
- validateOrder()

→ 命名风格相似，功能归类，认知负担低
```

#### 4. 连续性原则（Continuity）

**核心思想**：认知会沿着平滑的路径延伸

```
❌ 不连续的思维跳跃：
"需要设计数据库 → 选择技术栈 →
 编写代码 → 部署上线"

→ 缺少中间步骤，认知断层

✅ 连续的思维链：
"需求分析 → 架构设计 → 技术选型 →
 数据库设计 → API设计 → 编码实现 →
 测试验证 → 部署上线"

→ 每一步都自然过渡，认知流畅
```

#### 5. 闭合性原则（Closure）

**核心思想**：认知会自动补全不完整的模式

```
❌ 未闭合的思维：
"设计用户注册功能"

→ 认知不完整，会产生疑问

✅ 闭合的思维：
"设计用户注册功能：
├─ 输入：用户名、密码、邮箱
├─ 处理：验证、存储、发送确认邮件
└─ 输出：注册结果、用户ID"

→ 认知完整，没有疑问
```

### 🎯 结构化复杂任务的重要性

**为什么需要结构化？**

**1. 防止思维混乱**

```
❌ 无结构的思维：
"我需要做一个电商系统，要有商品管理、
用户管理、订单处理、支付、物流、
售后、统计、推荐、搜索、评论、
客服、营销、活动..."

→ 思维混乱，遗漏功能，逻辑不清

✅ 结构化的思维（格式塔）：
"电商系统 = 用户子系统 + 商品子系统 +
           交易子系统 + 服务子系统

用户子系统：
- 用户管理
- 认证授权
- 个人中心

商品子系统：
- 商品管理
- 库存管理
- 分类管理

交易子系统：
- 订单处理
- 支付系统
- 物流跟踪

服务子系统：
- 售后服务
- 数据统计
- 推荐系统"

→ 思维清晰，完整无遗漏
```

**2. 降低认知负担**

```
认知心理学研究：

工作记忆容量：7 ± 2 个项目（Miller, 1956）

❌ 未结构化：
一次性处理20个功能点
→ 超出工作记忆容量，认知超载

✅ 结构化：
5个模块，每个模块4个功能
→ 5 + 4 = 9个项目，在工作记忆容量内
→ 认知负担低，处理效率高
```

**3. 提高协作效率**

```
❌ 无结构协作：
开发者A："注册功能做完了"
开发者B："登录呢？"
开发者A："还没做"
开发者C："那测试呢？"
→ 协作混乱，信息不同步

✅ 结构化协作（格式塔）：
开发计划（整体可见）：
Phase 1 - 用户认证模块（整体）
  ├─ 注册功能 - 开发者A
  ├─ 登录功能 - 开发者B
  └─ 测试 - 开发者C

所有人看到同一个"整体"，协作高效
```

### 🎯 认知模板与格式塔原则

**模板如何体现格式塔原则？**

**Chain of Thought** → 连续性原则
- 建立平滑的思维路径
- 每一步自然过渡到下一步

**Few-Shot Learning** → 相似性原则
- 从相似示例中学习规律
- 应用规律到新情况

**Verification** → 闭合性原则
- 补全验证检查
- 确保思维完整

**Role Playing** → 整体性原则
- 从角色视角获得整体认知
- 避免片面分析

**Understanding** → 整体性 + 连续性
- 建立完整的认知框架
- 理解要素间的连续关系

---

## 全生命周期应用

### 📋 Idea阶段：从简单概念开始

**场景**：用户有一个模糊的想法

**格式塔应用**：
```
阶段1：最简整体（MVP概念）

核心想法："AI代码助手"

✅ 格式塔整体：
- 输入：开发者写的代码
- 处理：AI分析代码
- 输出：改进建议

→ 这是一个完整的"整体"，功能简单但完整

❌ 避免复杂化：
不要一开始就想：
- 支持所有编程语言
- 完整的IDE集成
- 团队协作功能
- 智能重构
- 自动测试生成

→ 这违反了"从简单到复杂"原则
```

**使用认知模板**：
```
使用 Understanding 模板：

🎯 核心目标
- 主要目的：帮助开发者提高代码质量
- 要解决：代码质量问题（重复、错误、风格）
- 最终交付：代码改进建议

📦 关键要素
- 核心组件：
  ├─ 代码分析引擎
  ├─ 建议生成器
  └─ 结果展示器
- 关键概念：静态分析、模式识别、最佳实践
- 关系网络：代码 → 分析 → 建议 → 展示

✅ 成功标准
- ✅ 能识别常见代码问题
- ✅ 建议准确率 > 80%
- ✅ 响应时间 < 2秒
```

### 📋 需求阶段：结构化功能需求

**场景**：有完整的需求文档

**格式塔应用**：
```
将需求组织成"整体"结构：

电商系统 = 用户 + 商品 + 交易 + 服务

每个子系统都是一个"整体"：
- 有清晰的边界
- 有明确的接口
- 内部高内聚
- 外部低耦合

应用相似性原则：
- 每个服务都有相似的接口结构
- 统一的错误处理模式
- 一致的命名规范

应用连续性原则：
- 用户 → 商品 → 订单 → 支付
- 流程自然延伸，无断裂
```

**使用认知模板**：
```
使用 Chain of Thought 模板：

📋 问题理解
- 核心需求：构建可扩展的电商系统
- 约束：支持100万日活
- 输出：系统架构方案

🔍 步骤分解（连续性原则）
- 步骤1：识别核心子系统（整体性）
- 步骤2：定义子系统接口（闭合性）
- 步骤3：设计服务交互（连续性）
- 步骤4：规划扩展机制（简单到复杂）

💭 中间推理
步骤1：识别核心子系统
- 核心业务流程：用户 → 商品 → 订单 → 支付
- 子系统拆分：
  ├─ 用户子系统
  ├─ 商品子系统
  ├─ 订单子系统
  └─ 支付子系统
- 每个子系统都是一个"整体"

步骤2：定义子系统接口
- 应用相似性原则：统一接口风格
- RESTful API规范
- 标准化响应格式

步骤3：设计服务交互
- 应用连续性原则：流程平滑
- 用户浏览 → 加入购物车 → 下单 → 支付
- 每一步都有明确的下一步

✅ 验证检查
- ✅ 每个子系统职责清晰
- ✅ 接口风格一致
- ✅ 流程无断裂
- ✅ 可独立扩展
```

### 📋 细化阶段：详细设计的结构化

**场景**：功能需要进一步细化

**格式塔应用**：
```
从简单到复杂演化：

阶段1：核心流程（简单整体）
用户注册 → 验证 → 存储 → 返回

阶段2：添加验证（演化）
用户注册 → 格式验证 → 唯一性验证 → 存储 → 返回

阶段3：添加增强（继续演化）
用户注册 → 格式验证 → 唯一性验证 →
          风险检查 → 存储 → 发送邮件 → 返回

关键：每个阶段都是完整的"整体"，
不是零散功能的堆砌
```

**使用认知模板**：
```
使用 Verification 模板：

🎯 初始判断
- 设计：用户注册API
- 初步结论：方案合理
- 置信度：70%

🔍 逻辑一致性检查
- 内部逻辑：
  - ✅ 输入验证 → 业务处理 → 数据存储
  - ✅ 错误处理分支清晰
- 因果关系：
  - ✅ 验证通过 → 存储
  - ✅ 验证失败 → 返回错误
- 闭合性：
  - ✅ 所有可能的路径都有处理
  - ✅ 没有未处理的异常

✅ 事实准确性检查
- 数据准确性：
  - ✅ 用户名长度限制合理（4-20字符）
  - ✅ 密码强度要求充分
- 概念正确性：
  - ✅ 使用标准HTTP状态码
  - ✅ RESTful风格

📋 完整性检查
- 必需元素：
  - ✅ 输入验证
  - ✅ 错误处理
  - ✅ 成功响应
  - ✅ 日志记录
- 边界情况：
  - ✅ 用户名重复
  - ✅ 邮箱格式错误
  - ✅ 网络超时

🔮 最终确认
- 方案符合格式塔原则：
  - ✅ 整体性：功能完整
  - ✅ 闭合性：所有路径处理
  - ✅ 连续性：流程平滑
- 最终结论：方案可行
- 新的置信度：90%
```

### 📋 智能阶段：智能体认知框架

**场景**：为智能体设计认知模板

**格式塔应用**：
```
智能体的认知框架应该体现格式塔原则：

局部智能体A（代码审查）：
- 整体性：专注于代码审查领域
- 相似性：使用一致的审查标准
- 连续性：审查流程平滑

局部智能体B（测试生成）：
- 整体性：专注于测试生成领域
- 相似性：使用一致的测试框架
- 连续性：生成流程平滑

协作：
- 每个智能体都是一个"整体"
- 智能体间通过接口协作
- 避免全局上下文膨胀
```

**使用认知模板**：
```
使用 Role Playing 模板：

🎭 角色定义
- 角色：代码审查专家
- 专业领域：静态分析、安全审计、性能优化
- 核心能力：识别代码问题、提供改进建议
- 思维特点：关注代码质量、安全性、可维护性

🔍 角色理解（整体性原则）
- 代码审查专家关注：
  - ✅ 代码的整体质量
  - ✅ 潜在的安全风险
  - ✅ 性能瓶颈
  - ✅ 可维护性
- 优先级：安全性 > 正确性 > 性能 > 风格

💡 角色分析
从专家视角分析代码：
1. **安全性检查**：
   - SQL注入
   - XSS漏洞
   - 权限问题
   - 硬编码密钥

2. **正确性检查**：
   - 边界条件
   - 异常处理
   - 资源释放
   - 并发问题

3. **性能分析**：
   - 算法复杂度
   - 资源使用
   - 缓存机会
   - 数据库查询

4. **可维护性**：
   - 代码风格
   - 命名规范
   - 注释质量
   - 模块化程度

🎯 角色建议
专家会建议：
- 优先修复安全问题
- 改进异常处理
- 优化性能瓶颈
- 统一代码风格

🤝 角色决策
专家会做出的决策：
- 决策依据：代码质量评分
- 最终选择：通过/需要修改/不通过
- 风险评估：潜在问题严重性
```

---

## 核心功能

### 1. 思维链模板 (Chain of Thought)

**格式塔原则**：连续性（Continuity）

**适用场景**：
- 解决复杂问题
- 多步骤推理
- 需要展示思考过程
- 逻辑推导

**模板结构**：

```
📋 问题理解（整体性）
- 核心需求是什么？
- 有哪些约束条件？
- 期望的输出是什么？

🔍 步骤分解（连续性）
- 步骤 1: [具体操作]
- 步骤 2: [具体操作] ← 自然延续步骤1
- 步骤 3: [具体操作] ← 自然延续步骤2
- ...

💭 中间推理（连续性）
步骤 1 的思考：
- 执行过程: [详细说明]
- 中间结果: [步骤1的输出]
- 验证: [确认步骤1正确] ← 闭合性

步骤 2 的思考：
- 依赖步骤1的结果 ← 连续性
- 执行过程: [详细说明]
- 中间结果: [步骤2的输出]

✅ 验证检查（闭合性）
- 逻辑一致性: [检查推理过程]
- 结果合理性: [评估最终答案]
- 边界情况: [考虑特殊场景]

📝 最终答案（整体性）
- 结论: [综合所有步骤的最终结果]
- 依据: [列出关键支撑点]
```

**示例**：

**问题**：设计一个支持10万并发的电商系统

**思维链分析**：

📋 问题理解（整体性）
- 核心需求: 设计高并发电商架构
- 约束: 支持10万并发用户
- 输出: 系统架构方案（完整的整体）

🔍 步骤分解（连续性）
- 步骤 1: 估算系统容量需求
- 步骤 2: 设计系统分层架构 ← 基于步骤1的容量
- 步骤 3: 选择技术栈 ← 适配步骤2的架构
- 步骤 4: 设计缓存策略 ← 优化步骤3的性能
- 步骤 5: 设计数据库方案 ← 支撑步骤4的缓存

💭 中间推理（连续性 + 闭合性）

步骤1: 容量估算
- 假设每用户10请求/秒
- 10万并发 = 100万 QPS
- 需要分布式架构 ← 结论闭合

步骤2: 分层架构
- 基于步骤1的100万 QPS ← 连续性
- 负载均衡层
- API网关层
- 应用服务层
- 数据存储层
- 缓存层
- 每层职责清晰 ← 整体性

✅ 验证检查（闭合性）
- 架构满足100万QPS要求
- 各层可独立扩展
- 符合高可用原则
- 所有关键技术点都有方案 ← 闭合

### 2. 少样本学习模板 (Few-Shot Learning)

**格式塔原则**：相似性（Similarity）

**适用场景**：
- 需要示例引导
- 模式识别
- 从示例学习规律
- 类似任务处理

**模板结构**：

```
📚 示例学习（相似性原则）

示例 1:
输入: [示例输入]
输出: [示例输出]
规律: [识别出的模式]

示例 2:
输入: [示例输入]
输出: [示例输出]
规律: [验证模式一致性]

示例 3:
输入: [示例输入]
输出: [示例输出]
规律: [总结通用规律]

🎯 应用规律（相似性应用）

当前任务: [新输入]
应用规律: [如何使用示例中的规律]
推理过程: [逐步应用]
生成输出: [基于规律的结果]

🔍 验证结果（闭合性）
- 是否遵循示例规律: [检查]
- 输出格式是否一致: [验证]
- 结果是否合理: [评估]
```

**示例**：

**任务**：根据示例生成API错误响应

📚 示例学习（相似性）

示例 1:
输入: 用户未找到 (user_id: 123 不存在)
输出:
```json
{
  "error": "USER_NOT_FOUND",
  "message": "User with ID 123 does not exist",
  "code": 404
}
```
规律: 使用大写下划线命名错误类型，包含友好消息和HTTP状态码

示例 2:
输入: 验证失败 (email格式无效)
输出:
```json
{
  "error": "VALIDATION_ERROR",
  "message": "Invalid email format",
  "code": 400
}
```
规律: 验证错误使用400码，描述具体验证问题 ← 相似模式

示例 3:
输入: 权限不足 (无权访问资源)
输出:
```json
{
  "error": "PERMISSION_DENIED",
  "message": "Insufficient permissions to access this resource",
  "code": 403
}
```
规律: 权限错误使用403码，说明权限问题 ← 相似模式

🎯 应用规律（相似性应用）

当前任务: 令牌过期
应用规律:
- 错误类型: TOKEN_EXPIRED (大写下划线) ← 应用相似性
- 消息: 说明令牌已过期 ← 应用相似性
- 状态码: 401 (未授权) ← 应用相似性

生成输出:
```json
{
  "error": "TOKEN_EXPIRED",
  "message": "Authentication token has expired",
  "code": 401
}
```

### 3. 验证框架模板 (Verification)

**格式塔原则**：闭合性（Closure）+ 整体性（Whole）

**适用场景**：
- 验证解决方案
- 质量检查
- 错误排查
- 结果确认

**模板结构**：

```
🎯 初始判断（整体性）
- 问题: [需要验证的内容]
- 初步结论: [第一印象判断]
- 置信度: [有多少把握]

🔍 逻辑一致性检查（连续性）
- 内部逻辑: [检查推理过程]
- 因果关系: [验证因果链条]
- 前提假设: [检查假设合理性]
- 发现问题: [识别的矛盾或漏洞]

✅ 事实准确性检查（相似性）
- 数据准确性: [验证数据和数字]
- 概念正确性: [检查术语和概念]
- 引用准确性: [验证引用和参考]
- 发现错误: [识别的事实错误]

📋 完整性检查（闭合性）
- 必需元素: [检查是否包含所有必要部分]
- 边界情况: [考虑特殊情况]
- 异常处理: [检查错误情况]
- 发现遗漏: [识别的缺失内容]

🔮 最终确认（整体性）
- 检查汇总: [总结发现的问题]
- 修正建议: [如何改进]
- 最终结论: [验证后的最终判断]
- 新的置信度: [修正后的把握程度]
```

**示例**：

**验证**：数据库设计方案

🎯 初始判断（整体性）
- 方案: 使用 MySQL + Redis 组合
- 初步结论: 方案合理
- 置信度: 70%

🔍 逻辑一致性检查（连续性）
- 内部逻辑:
  - ✅ MySQL 持久化存储
  - ✅ Redis 缓存热点数据
  - ✅ 读写分离降低主库压力
  - 连贯性：缓存 → 读 → 写 ← 连续合理
- 因果关系:
  - ✅ 缓存可提升读取性能
  - ✅ 读写分离可提升写入性能
- 前提假设:
  - ✅ 假设数据量在百万级
  - ⚠️ 但未说明预期数据量

✅ 事实准确性检查（相似性）
- 数据准确性:
  - ✅ MySQL 最大连接数配置合理
  - ✅ Redis 内存配置充足
- 概念正确性:
  - ✅ 术语使用准确
  - ✅ 技术选型说明正确

📋 完整性检查（闭合性）
- 必需元素:
  - ✅ 包含备份策略
  - ✅ 包含监控方案
  - ❌ 缺少容灾方案 ← 未闭合
- 边界情况:
  - ❌ 未考虑缓存雪崩 ← 未闭合
  - ❌ 未考虑缓存穿透 ← 未闭合

🔮 最终确认（整体性）
- 检查汇总:
  - 逻辑基本正确
  - 缺少容灾和异常处理
- 修正建议:
  1. 添加异地容灾方案
  2. 设计缓存防护机制
  3. 补充降级策略
- 最终结论: 方案基本可行，需补充异常处理
- 新的置信度: 85% (补充完善后)

### 4. 角色扮演模板 (Role Playing)

**格式塔原则**：整体性（Whole）

**适用场景**：
- 从专业角度分析
- 多视角思考
- 模拟专家意见
- 角色化分析

**模板结构**：

```
🎭 角色定义（整体性）
- 角色: [专业身份]
- 专业领域: [专长范围]
- 核心能力: [能做什么]
- 思维特点: [如何思考]

🔍 角色理解（整体性）
- 这个角色会如何理解任务?
- 角色的关注点是什么?
- 角色的优先级如何?

💡 角色分析（相似性）
从角色视角分析:
- 维度 1: [角色的专业观点]
- 维度 2: [角色的专业观点]
- 维度 3: [角色的专业观点]

🎯 角色建议（连续性）
这个角色会给出什么建议?
- 建议 1: [基于角色的专业建议]
- 建议 2: [基于角色的专业建议]
- 建议 3: [基于角色的专业建议]

🤝 角色决策（闭合性）
这个角色会做什么决策?
- 决策依据: [角色的判断标准]
- 最终选择: [角色的决定]
- 风险评估: [角色认为的风险]
```

**示例**：

**任务**：从系统架构师角度评估技术方案

🎭 角色定义（整体性）
- 角色: 资深系统架构师
- 专业领域: 分布式系统、微服务、高并发
- 核心能力: 系统设计、性能优化、技术选型
- 思维特点: 关注可扩展性、可维护性、成本效益

🔍 角色理解（整体性）
- 架构师会关注:
  - ✅ 系统的长期可维护性
  - ✅ 技术栈的成熟度
  - ✅ 团队的技术能力
  - ✅ 开发和运维成本
- 优先级: 可维护性 > 性能 > 功能

💡 角色分析（相似性 - 从架构师视角的思考模式）

从架构师视角分析当前方案:
1. **技术选型**:
   - ✅ 选择成熟的技术栈
   - ⚠️ 新技术引入需谨慎
   - ✅ 考虑社区支持和生态

2. **架构设计**:
   - ✅ 分层架构合理
   - ⚠️ 服务边界需更清晰
   - ✅ 预留扩展点

3. **性能考量**:
   - ✅ 引入缓存是必要的
   - ✅ 读写分离架构合理
   - ⚠️ 需要性能测试验证

🎯 角色建议（连续性 - 从短期到长期）

架构师会建议:
1. **短期**:
   - 完善服务接口设计
   - 建立性能监控体系
   - 编写技术文档

2. **中期**:
   - 优化数据库访问
   - 引入消息队列
   - 实施自动化测试

3. **长期**:
   - 服务网格化
   - 多活架构演进
   - 持续性能优化

🤝 角色决策（闭合性）

架构师会做出的决策:
- 决策依据: 当前方案基本可行，需要细节完善
- 最终选择: 采用该方案，但需先做 POC 验证
- 风险评估:
  - 风险1: 团队对新技术的熟练度
  - 风险2: 性能是否达标需要实测
  - 建议: 先小范围试点，再全面推广

### 5. 理解框架模板 (Understanding)

**格式塔原则**：整体性（Whole）+ 相似性（Similarity）

**适用场景**：
- 深度理解概念
- 全面分析需求
- 识别关键要素
- 评估完成标准

**模板结构**：

```
🎯 核心目标（整体性）
- 主要目的是什么?
- 要解决什么问题?
- 最终交付物是什么?

📦 关键要素（整体性 + 相似性）
- 核心组件: [主要组成部分]
- 关键概念: [重要术语和概念]
- 关系网络: [各要素间的关系]
- 依赖关系: [依赖的外部因素]

⚙️ 约束条件（闭合性）
- 技术约束: [技术限制]
- 资源约束: [资源限制]
- 时间约束: [时间限制]
- 其他约束: [其他限制]

✅ 成功标准（闭合性）
- 如何判断成功?
- 有哪些可量化指标?
- 质量标准是什么?
- 验收标准是什么?

⚠️ 潜在风险（整体性）
- 技术风险: [技术层面的风险]
- 业务风险: [业务层面的风险]
- 资源风险: [资源相关的风险]
- 时间风险: [进度相关的风险]

📊 优先级分析（相似性）
- 必须有: [不可或缺的要素]
- 应该有: [重要的但非必需]
- 可以有: [锦上添花的要素]
- 不需要: [明确不需要的]
```

**示例**：

**任务**：理解微服务架构需求

🎯 核心目标（整体性）
- 主要目的: 构建可扩展、高可用的电商平台
- 要解决的问题: 单体应用难以扩展、部署缓慢、技术栈单一
- 最终交付: 微服务化的电商系统（完整的整体）

📦 关键要素（整体性 + 相似性）

核心组件（整体性）:
- 用户服务
- 商品服务
- 订单服务
- 支付服务
- 库存服务
- 通知服务

关键概念（相似性 - 所有服务都有相似的关注点）:
- 服务拆分粒度
- 服务间通信
- 服务发现
- 配置管理
- 链路追踪

关系网络（连续性 - 流程延伸）:
```
用户 → 商品 → 订单 → 支付
  ↓      ↓      ↓      ↓
库存 ← 订单 ← 支付 → 通知
```

依赖关系（闭合性 - 所有依赖都明确）:
- 依赖服务发现机制
- 依赖配置中心
- 依赖消息队列
- 依赖监控系统

⚙️ 约束条件（闭合性）
- 技术约束: 必须使用 Node.js 和 TypeScript
- 资源约束: 团队规模10人，预算有限
- 时间约束: 6个月内上线
- 其他约束: 需兼容现有遗留系统

✅ 成功标准（闭合性 - 完整定义）
- 可量化指标:
  - 支持日活用户100万+
  - 接口响应时间 < 200ms (P99)
  - 系统可用性 99.9%
- 质量标准:
  - 代码覆盖率 > 80%
  - 通过安全审计
  - 文档完整性
- 验收标准:
  - 压力测试通过
  - 灰度发布成功
  - 用户反馈良好

⚠️ 潜在风险（整体性 - 全面考虑）
- 技术风险:
  - 分布式事务处理复杂
  - 服务间调用延迟
  - 数据一致性难以保证
- 业务风险:
  - 服务拆分可能影响业务连贯性
  - 迁移过程可能影响现有业务
- 资源风险:
  - 运维复杂度增加
  - 服务器成本上升
- 时间风险:
  - 团队学习曲线
  - 技术难题可能延期

📊 优先级分析（相似性 - 按重要性分类）
- 必须有:
  - ✅ 服务注册与发现
  - ✅ API网关
  - ✅ 配置中心
  - ✅ 监控系统
- 应该有:
  - ✅ 链路追踪
  - ✅ 消息队列
  - ✅ 缓存服务
- 可以有:
  - ⚠️ 服务网格
  - ⚠️ 智能路由
- 不需要:
  - ❌ 过度复杂的分布式事务
  - ❌ 不必要的微服务拆分

---

## 模板选择指南

根据任务特点选择合适的模板：

| 任务特点 | 格式塔原则 | 推荐模板 | 理由 |
|---------|-----------|---------|------|
| 复杂问题求解 | 连续性 | Chain of Thought | 分步推理，建立连续思维路径 |
| 需要示例引导 | 相似性 | Few-Shot Learning | 从相似示例中学习规律 |
| 需要验证结果 | 闭合性 | Verification | 补全检查，确保思维完整 |
| 需要专业视角 | 整体性 | Role Playing | 从角色视角获得整体认知 |
| 需要深度理解 | 整体性+相似性 | Understanding | 建立完整框架，识别相似要素 |

---

## 组合使用

多个模板可以组合使用，体现多个格式塔原则：

**示例**: Few-Shot + Chain of Thought
1. 先用 Few-Shot 学习示例模式（相似性原则）
2. 再用 Chain of Thought 分步应用（连续性原则）

**示例**: Role Playing + Verification
1. 从角色视角给出初步方案（整体性原则）
2. 用 Verification 框架验证方案（闭合性原则）

**示例**: Understanding + Chain of Thought
1. 先建立整体认知框架（整体性原则）
2. 再分步骤详细设计（连续性原则）

---

## 质量检查清单

### 格式塔原则检查

**整体性检查**：
- [ ] 是否建立了完整的认知框架
- [ ] 各要素是否组成一个整体
- [ ] 边界是否清晰

**连续性检查**：
- [ ] 思维路径是否平滑
- [ ] 步骤间是否自然过渡
- [ ] 是否有断裂或跳跃

**相似性检查**：
- [ ] 相似元素是否归类
- [ ] 模式是否一致
- [ ] 风格是否统一

**闭合性检查**：
- [ ] 所有必要环节是否完整
- [ ] 是否有未处理的分支
- [ ] 是否有遗漏

### 模板使用检查

- [ ] 选择合适的模板
- [ ] 遵循模板结构
- [ ] 完整执行各步骤
- [ ] 提供清晰的输出
- [ ] 逻辑连贯一致
- [ ] 结果可验证

---

## 协作技能

- **dnaspec-task-decomposer**: 任务分解，应用格式塔原则
- **dnaspec-context-analysis**: 分析上下文，识别认知结构
- **dnaspec-architect**: 整体架构，体现整体性原则

---

## 关键成就

1. ✅ **格式塔认知原则** - 深入解释整体性、连续性、相似性、闭合性
2. ✅ **结构化复杂任务** - 防止思维混乱，降低认知负担
3. ✅ **从简单到复杂** - 支持系统自然演化
4. ✅ **五种认知模板** - 体现不同格式塔原则
5. ✅ **全生命周期应用** - Idea→需求→细化→智能四阶段
6. ✅ **组合使用** - 多个原则协同应用

---

*此技能基于格式塔认知心理学原则，通过结构化认知模板，帮助组织复杂思维，降低认知负担，防止思维混乱，支持从简单到复杂的系统演化。*
